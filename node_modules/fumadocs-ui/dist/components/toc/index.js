'use client';

import { cn } from "../../utils/cn.js";
import { mergeRefs } from "../../utils/merge-refs.js";
import { createContext, use, useEffect, useEffectEvent, useRef } from "react";
import { jsx } from "react/jsx-runtime";
import * as Primitive from "fumadocs-core/toc";
import { useOnChange } from "fumadocs-core/utils/use-on-change";

//#region src/components/toc/index.tsx
const TOCContext = createContext([]);
function useTOCItems() {
	return use(TOCContext);
}
function TOCProvider({ toc, children, ...props }) {
	return /* @__PURE__ */ jsx(TOCContext, {
		value: toc,
		children: /* @__PURE__ */ jsx(Primitive.AnchorProvider, {
			toc,
			...props,
			children
		})
	});
}
function TOCScrollArea({ ref, className, ...props }) {
	const viewRef = useRef(null);
	return /* @__PURE__ */ jsx("div", {
		ref: mergeRefs(viewRef, ref),
		className: cn("relative min-h-0 text-sm ms-px overflow-auto [scrollbar-width:none] mask-[linear-gradient(to_bottom,transparent,white_16px,white_calc(100%-16px),transparent)] py-3", className),
		...props,
		children: /* @__PURE__ */ jsx(Primitive.ScrollProvider, {
			containerRef: viewRef,
			children: props.children
		})
	});
}
function TocThumb({ containerRef, ...props }) {
	const thumbRef = useRef(null);
	const active = Primitive.useActiveAnchors();
	function update(info) {
		const element = thumbRef.current;
		if (!element) return;
		element.style.setProperty("--fd-top", `${info[0]}px`);
		element.style.setProperty("--fd-height", `${info[1]}px`);
	}
	const onPrint = useEffectEvent(() => {
		if (containerRef.current) update(calc(containerRef.current, active));
	});
	useEffect(() => {
		if (!containerRef.current) return;
		const container = containerRef.current;
		const observer = new ResizeObserver(onPrint);
		observer.observe(container);
		return () => {
			observer.disconnect();
		};
	}, [containerRef]);
	useOnChange(active, () => {
		if (containerRef.current) update(calc(containerRef.current, active));
	});
	return /* @__PURE__ */ jsx("div", {
		ref: thumbRef,
		"data-hidden": active.length === 0,
		...props
	});
}
function calc(container, active) {
	if (active.length === 0 || container.clientHeight === 0) return [0, 0];
	let upper = Number.MAX_VALUE, lower = 0;
	for (const item of active) {
		const element = container.querySelector(`a[href="#${item}"]`);
		if (!element) continue;
		const styles = getComputedStyle(element);
		upper = Math.min(upper, element.offsetTop + parseFloat(styles.paddingTop));
		lower = Math.max(lower, element.offsetTop + element.clientHeight - parseFloat(styles.paddingBottom));
	}
	return [upper, lower - upper];
}

//#endregion
export { TOCProvider, TOCScrollArea, TocThumb, useTOCItems };