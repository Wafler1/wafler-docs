{"version":3,"sources":["../../../src/lib/vite-plugins/allow-server.ts"],"sourcesContent":["import MagicString from 'magic-string';\nimport type { Plugin } from 'vite';\nimport { parseAstAsync } from 'vite';\n\ntype ProgramNode = Awaited<ReturnType<typeof parseAstAsync>>;\ntype BodyItem = ProgramNode['body'][number];\ntype VariableDeclaration = BodyItem & {\n  type: 'VariableDeclaration';\n};\ntype VariableDeclarator = VariableDeclaration['declarations'][number];\ntype ImportDeclaration = BodyItem & {\n  type: 'ImportDeclaration';\n};\ntype ImportSpecifier = ImportDeclaration['specifiers'][number] & {\n  type: 'ImportSpecifier';\n};\ntype ExportNamedDeclaration = BodyItem & {\n  type: 'ExportNamedDeclaration';\n};\ntype ExportSpecifier = ExportNamedDeclaration['specifiers'][number] & {\n  type: 'ExportSpecifier';\n};\ntype ExpressionStatement = BodyItem & {\n  type: 'ExpressionStatement';\n};\ntype Expression = ExpressionStatement['expression'];\ntype AstNode = BodyItem | Expression | VariableDeclarator; // not fully covered\ntype CallExpression = Expression & { type: 'CallExpression' };\ntype CallArguments = CallExpression['arguments'];\n\nconst isNode = (value: unknown): value is AstNode =>\n  typeof (value as { type?: unknown })?.type === 'string'; // heuristic\n\nconst isNodeWithRange = (\n  node: AstNode,\n): node is AstNode & { start: number; end: number } =>\n  typeof (node as { start?: unknown })?.start === 'number' &&\n  typeof (node as { end?: unknown })?.end === 'number';\n\nconst getImportedName = (specifier: ImportSpecifier) =>\n  specifier.imported.type === 'Identifier'\n    ? specifier.imported.name\n    : String(specifier.imported.value);\n\nconst getExportedName = (specifier: ExportSpecifier) =>\n  specifier.exported.type === 'Identifier'\n    ? specifier.exported.name\n    : String(specifier.exported.value);\n\nconst getLocalExportName = (specifier: ExportSpecifier) =>\n  specifier.local.type === 'Identifier'\n    ? specifier.local.name\n    : typeof specifier.local.value === 'string'\n      ? specifier.local.value\n      : null;\n\nconst getExpressionFromArguments = (args: CallArguments) => {\n  if (args.length !== 1) {\n    throw new Error('allowServer should have exactly one argument');\n  }\n  const arg = args[0]!;\n  const argument = arg.type === 'SpreadElement' ? arg.argument : arg;\n  if (!isNodeWithRange(argument)) {\n    throw new Error('Missing range');\n  }\n  return argument;\n};\n\nconst isUseDirective = (stmt: BodyItem, directive: string) =>\n  stmt.type === 'ExpressionStatement' &&\n  stmt.expression.type === 'Literal' &&\n  stmt.expression.value === directive;\n\nconst getDeclarationId = (item: BodyItem) =>\n  (item.type === 'FunctionDeclaration' || item.type === 'ClassDeclaration') &&\n  item.id.type === 'Identifier' &&\n  item.id;\n\nconst transformExportedClientThings = (mod: ProgramNode) => {\n  const exportNames = new Set<string>();\n  // HACK this doesn't cover all cases\n  const allowServerItems = new Map<\n    string,\n    Expression & { start: number; end: number }\n  >();\n  const allowServerDependencies = new Set<string>();\n  const visited = new WeakSet<AstNode>();\n  const findDependencies = (node: AstNode) => {\n    if (visited.has(node)) {\n      return;\n    }\n    visited.add(node);\n    if (node.type === 'Identifier') {\n      if (!allowServerItems.has(node.name) && !exportNames.has(node.name)) {\n        allowServerDependencies.add(node.name);\n      }\n    }\n    Object.values(node).forEach((value: unknown) => {\n      (Array.isArray(value) ? value : [value]).forEach((v: unknown) => {\n        if (isNode(v)) {\n          findDependencies(v);\n        }\n      });\n    });\n  };\n  // Pass 1: find allowServer identifier\n  let allowServer = 'unstable_allowServer';\n  for (const item of mod.body) {\n    if (\n      item.type === 'ImportDeclaration' &&\n      item.source.type === 'Literal' &&\n      item.source.value === 'waku/client'\n    ) {\n      for (const specifier of item.specifiers) {\n        if (\n          specifier.type === 'ImportSpecifier' &&\n          specifier.imported.type === 'Identifier' &&\n          specifier.imported.name === allowServer\n        ) {\n          allowServer = specifier.local.name;\n          break;\n        }\n      }\n      break;\n    }\n  }\n  // Pass 2: collect export names and allowServer names\n  for (const item of mod.body) {\n    if (item.type === 'ExportNamedDeclaration') {\n      if (\n        item.declaration?.type === 'FunctionDeclaration' &&\n        item.declaration.id\n      ) {\n        exportNames.add(item.declaration.id.name);\n      } else if (\n        item.declaration?.type === 'ClassDeclaration' &&\n        item.declaration.id\n      ) {\n        exportNames.add(item.declaration.id.name);\n      } else if (item.declaration?.type === 'VariableDeclaration') {\n        for (const d of item.declaration.declarations) {\n          if (d.id.type === 'Identifier') {\n            if (\n              d.init?.type === 'CallExpression' &&\n              d.init.callee.type === 'Identifier' &&\n              d.init.callee.name === allowServer\n            ) {\n              const arg = getExpressionFromArguments(d.init.arguments);\n              allowServerItems.set(d.id.name, arg);\n              findDependencies(d.init);\n            } else {\n              exportNames.add(d.id.name);\n            }\n          }\n        }\n      }\n      for (const s of item.specifiers) {\n        if (s.type === 'ExportSpecifier') {\n          const localName = getLocalExportName(s);\n          if (localName && allowServerItems.has(localName)) {\n            continue;\n          }\n          exportNames.add(getExportedName(s));\n        }\n      }\n    } else if (item.type === 'ExportDefaultDeclaration') {\n      exportNames.add('default');\n    } else if (item.type === 'ExportAllDeclaration') {\n      if (item.exported?.type === 'Identifier') {\n        exportNames.add(item.exported.name);\n      }\n    } else if (item.type === 'VariableDeclaration') {\n      for (const d of item.declarations) {\n        if (\n          d.id.type === 'Identifier' &&\n          d.init?.type === 'CallExpression' &&\n          d.init.callee.type === 'Identifier' &&\n          d.init.callee.name === allowServer\n        ) {\n          const arg = getExpressionFromArguments(d.init.arguments);\n          allowServerItems.set(d.id.name, arg);\n          findDependencies(d.init);\n        }\n      }\n    }\n  }\n  // Pass 3: collect dependencies\n  let dependenciesSize: number;\n  do {\n    dependenciesSize = allowServerDependencies.size;\n    for (const item of mod.body) {\n      if (item.type === 'VariableDeclaration') {\n        for (const d of item.declarations) {\n          if (\n            d.id.type === 'Identifier' &&\n            allowServerDependencies.has(d.id.name)\n          ) {\n            findDependencies(d);\n          }\n        }\n      } else {\n        const declId = getDeclarationId(item);\n        if (declId && allowServerDependencies.has(declId.name)) {\n          findDependencies(item);\n        }\n      }\n    }\n  } while (dependenciesSize < allowServerDependencies.size);\n  allowServerDependencies.delete(allowServer);\n  return { allowServerDependencies, allowServerItems, exportNames };\n};\n\nconst shouldKeepStatement = (stmt: BodyItem, dependencies: Set<string>) => {\n  if (stmt.type === 'ImportDeclaration') {\n    return stmt.specifiers.some(\n      (s) =>\n        s.type === 'ImportSpecifier' &&\n        (dependencies.has(getImportedName(s)) ||\n          dependencies.has(s.local.name)),\n    );\n  }\n  if (stmt.type === 'VariableDeclaration') {\n    return stmt.declarations.some(\n      (d) => d.id.type === 'Identifier' && dependencies.has(d.id.name),\n    );\n  }\n  const declId = getDeclarationId(stmt);\n  if (declId) {\n    return dependencies.has(declId.name);\n  }\n  return false;\n};\n\nconst hasDirective = (mod: ProgramNode, directive: string) => {\n  for (const item of mod.body) {\n    if (\n      item.type === 'ExpressionStatement' &&\n      item.expression.type === 'Literal' &&\n      item.expression.value === directive\n    ) {\n      return true;\n    }\n  }\n  return false;\n};\n\nexport function allowServerPlugin(): Plugin {\n  return {\n    name: 'waku:vite-plugins:allow-server',\n    async transform(code) {\n      if (this.environment.name !== 'rsc') {\n        return;\n      }\n      if (!code.includes('use client')) {\n        return;\n      }\n\n      const mod = await parseAstAsync(code, { jsx: true });\n      if (!hasDirective(mod, 'use client')) {\n        return;\n      }\n\n      const { allowServerDependencies, allowServerItems, exportNames } =\n        transformExportedClientThings(mod);\n\n      const s = new MagicString(code);\n      for (const item of mod.body) {\n        if (!isNodeWithRange(item)) {\n          throw new Error('Expected NodeWithRange');\n        }\n        if (isUseDirective(item, 'use client')) {\n          s.remove(item.start, item.end);\n          continue;\n        }\n        if (shouldKeepStatement(item, allowServerDependencies)) {\n          continue;\n        }\n        s.remove(item.start, item.end);\n      }\n\n      for (const [allowServerName, callExp] of allowServerItems) {\n        const expressionSource = code.slice(callExp.start, callExp.end);\n        s.append(`\\nexport const ${allowServerName} = ${expressionSource};`);\n      }\n      let newCode = s.toString().replace(/\\n+/g, '\\n');\n      for (const name of exportNames) {\n        const value = `() => { throw new Error('It is not possible to invoke a client function from the server: ${JSON.stringify(name)}') }`;\n        newCode += `\\nexport ${name === 'default' ? name : `const ${name} =`} ${value};`;\n      }\n      return '\"use client\";' + newCode.trim() + '\\n';\n    },\n  };\n}\n"],"names":["MagicString","parseAstAsync","isNode","value","type","isNodeWithRange","node","start","end","getImportedName","specifier","imported","name","String","getExportedName","exported","getLocalExportName","local","getExpressionFromArguments","args","length","Error","arg","argument","isUseDirective","stmt","directive","expression","getDeclarationId","item","id","transformExportedClientThings","mod","exportNames","Set","allowServerItems","Map","allowServerDependencies","visited","WeakSet","findDependencies","has","add","Object","values","forEach","Array","isArray","v","allowServer","body","source","specifiers","declaration","d","declarations","init","callee","arguments","set","s","localName","dependenciesSize","size","declId","delete","shouldKeepStatement","dependencies","some","hasDirective","allowServerPlugin","transform","code","environment","includes","jsx","remove","allowServerName","callExp","expressionSource","slice","append","newCode","toString","replace","JSON","stringify","trim"],"mappings":"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"}