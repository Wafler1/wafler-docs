{"version":3,"sources":["../../src/router/define-router.tsx"],"sourcesContent":["import type { ReactNode } from 'react';\nimport { createCustomError, getErrorInfo } from '../lib/utils/custom-errors.js';\nimport { getPathMapping, path2regexp } from '../lib/utils/path.js';\nimport type { PathSpec } from '../lib/utils/path.js';\nimport { base64ToStream, streamToBase64 } from '../lib/utils/stream.js';\nimport { createTaskRunner } from '../lib/utils/task-runner.js';\nimport { unstable_defineHandlers as defineHandlers } from '../minimal/server.js';\nimport { unstable_getContext as getContext } from '../server.js';\nimport { INTERNAL_ServerRouter } from './client.js';\nimport {\n  HAS404_ID,\n  IS_STATIC_ID,\n  ROUTE_ID,\n  SKIP_HEADER,\n  decodeRoutePath,\n  decodeSliceId,\n  encodeRoutePath,\n  encodeSliceId,\n} from './common.js';\n\nconst isStringArray = (x: unknown): x is string[] =>\n  Array.isArray(x) && x.every((y) => typeof y === 'string');\n\nconst parseRscParams = (\n  rscParams: unknown,\n): {\n  query: string;\n} => {\n  if (rscParams instanceof URLSearchParams) {\n    return { query: rscParams.get('query') || '' };\n  }\n  if (\n    typeof (rscParams as { query?: undefined } | undefined)?.query === 'string'\n  ) {\n    return { query: (rscParams as { query: string }).query };\n  }\n  return { query: '' };\n};\n\nconst RSC_PATH_SYMBOL = Symbol('RSC_PATH');\nconst RSC_PARAMS_SYMBOL = Symbol('RSC_PARAMS');\n\nconst setRscPath = (rscPath: string) => {\n  try {\n    const context = getContext();\n    (context as unknown as Record<typeof RSC_PATH_SYMBOL, unknown>)[\n      RSC_PATH_SYMBOL\n    ] = rscPath;\n  } catch {\n    // ignore\n  }\n};\n\nconst setRscParams = (rscParams: unknown) => {\n  try {\n    const context = getContext();\n    (context as unknown as Record<typeof RSC_PARAMS_SYMBOL, unknown>)[\n      RSC_PARAMS_SYMBOL\n    ] = rscParams;\n  } catch {\n    // ignore\n  }\n};\n\nexport function unstable_getRscPath(): string | undefined {\n  try {\n    const context = getContext();\n    return (context as unknown as Record<typeof RSC_PATH_SYMBOL, string>)[\n      RSC_PATH_SYMBOL\n    ];\n  } catch {\n    return undefined;\n  }\n}\n\nexport function unstable_getRscParams(): unknown {\n  try {\n    const context = getContext();\n    return (context as unknown as Record<typeof RSC_PARAMS_SYMBOL, unknown>)[\n      RSC_PARAMS_SYMBOL\n    ];\n  } catch {\n    return undefined;\n  }\n}\n\nconst getNonce = () => {\n  try {\n    const context = getContext();\n    return context.nonce;\n  } catch {\n    return undefined;\n  }\n};\n\nconst RERENDER_SYMBOL = Symbol('RERENDER');\ntype Rerender = (rscPath: string, rscParams?: unknown) => void;\n\nconst setRerender = (rerender: Rerender) => {\n  try {\n    const context = getContext();\n    (context as unknown as Record<typeof RERENDER_SYMBOL, Rerender>)[\n      RERENDER_SYMBOL\n    ] = rerender;\n  } catch {\n    // ignore\n  }\n};\n\nconst getRerender = (): Rerender => {\n  const context = getContext();\n  return (context as unknown as Record<typeof RERENDER_SYMBOL, Rerender>)[\n    RERENDER_SYMBOL\n  ];\n};\n\nconst is404 = (pathSpec: PathSpec) =>\n  pathSpec.length === 1 &&\n  pathSpec[0]!.type === 'literal' &&\n  pathSpec[0]!.name === '404';\n\nconst pathSpec2pathname = (pathSpec: PathSpec) => {\n  if (pathSpec.some(({ type }) => type !== 'literal')) {\n    return undefined;\n  }\n  return '/' + pathSpec.map(({ name }) => name!).join('/');\n};\n\nconst htmlPath2pathname = (htmlPath: string): string =>\n  htmlPath === '/404' ? '404.html' : htmlPath + '/index.html';\n\nexport function unstable_rerenderRoute(pathname: string, query?: string) {\n  const rscPath = encodeRoutePath(pathname);\n  getRerender()(rscPath, query && new URLSearchParams({ query }));\n}\n\nexport function unstable_notFound(): never {\n  throw createCustomError('Not Found', { status: 404 });\n}\n\nexport function unstable_redirect(\n  location: string,\n  status: 303 | 307 | 308 = 307,\n): never {\n  throw createCustomError('Redirect', { status, location });\n}\n\ntype SlotId = string;\n\nconst ROOT_SLOT_ID = 'root';\nconst ROUTE_SLOT_ID_PREFIX = 'route:';\nconst SLICE_SLOT_ID_PREFIX = 'slice:';\n\nconst assertNonReservedSlotId = (slotId: SlotId) => {\n  if (\n    slotId === ROOT_SLOT_ID ||\n    slotId.startsWith(ROUTE_SLOT_ID_PREFIX) ||\n    slotId.startsWith(SLICE_SLOT_ID_PREFIX)\n  ) {\n    throw new Error('Element ID cannot be \"root\", \"route:*\" or \"slice:*\"');\n  }\n};\n\ntype RendererOption = { pathname: string; query: string | undefined };\n\ntype RouteConfig = {\n  type: 'route';\n  path: PathSpec;\n  isStatic: boolean;\n  pathPattern?: PathSpec;\n  rootElement: {\n    isStatic: boolean;\n    renderer: (option: RendererOption) => ReactNode;\n  };\n  routeElement: {\n    isStatic: boolean;\n    renderer: (option: RendererOption) => ReactNode;\n  };\n  elements: Record<\n    SlotId,\n    {\n      isStatic: boolean;\n      renderer: (option: RendererOption) => ReactNode;\n    }\n  >;\n  noSsr?: boolean;\n  slices?: string[];\n};\n\ntype ApiConfig = {\n  type: 'api';\n  path: PathSpec;\n  isStatic: boolean;\n  handler: (req: Request) => Promise<Response>;\n};\n\ntype SliceConfig = {\n  type: 'slice';\n  id: string;\n  isStatic: boolean;\n  renderer: () => Promise<ReactNode>;\n};\n\nconst getRouterPrefetchCode = (path2moduleIds: Record<string, string[]>) => {\n  const moduleIdSet = new Set<string>();\n  Object.values(path2moduleIds).forEach((ids) =>\n    ids.forEach((id) => moduleIdSet.add(id)),\n  );\n  const ids = Array.from(moduleIdSet);\n  const path2idxs: Record<string, number[]> = {};\n  Object.entries(path2moduleIds).forEach(([path, ids]) => {\n    path2idxs[path] = ids.map((id) => ids.indexOf(id));\n  });\n  return `\nglobalThis.__WAKU_ROUTER_PREFETCH__ = (path, callback) => {\n  const ids = ${JSON.stringify(ids)};\n  const path2idxs = ${JSON.stringify(path2idxs)};\n  const key = Object.keys(path2idxs).find((key) => new RegExp(key).test(path));\n  for (const idx of path2idxs[key] || []) {\n    callback(ids[idx]);\n  }\n};\n`;\n};\n\nexport function unstable_defineRouter(fns: {\n  getConfigs: () => Promise<Iterable<RouteConfig | ApiConfig | SliceConfig>>;\n}) {\n  // This is an internal type for caching\n  type MyConfig = {\n    configs: (RouteConfig | ApiConfig | SliceConfig)[];\n    has404: boolean;\n  };\n\n  let cachedMyConfig: MyConfig | undefined;\n  const getMyConfig = async (): Promise<MyConfig> => {\n    if (!cachedMyConfig) {\n      const configs = Array.from(await fns.getConfigs());\n      let has404 = false;\n      configs.forEach((item) => {\n        if (item.type === 'route') {\n          Object.keys(item.elements).forEach(assertNonReservedSlotId);\n          if (!has404 && is404(item.path)) {\n            has404 = true;\n          }\n        }\n      });\n      cachedMyConfig = { configs, has404 };\n    }\n    return cachedMyConfig;\n  };\n\n  const getPathConfigItem = async (pathname: string) => {\n    const myConfig = await getMyConfig();\n    const found = myConfig.configs.find(\n      (item): item is typeof item & { type: 'route' | 'api' } =>\n        (item.type === 'route' || item.type === 'api') &&\n        !!getPathMapping(item.path, pathname),\n    );\n    return found;\n  };\n\n  const getSliceElement = async (\n    sliceConfig: {\n      id: string;\n      isStatic: boolean;\n      renderer: () => Promise<ReactNode>;\n    },\n    getCachedElement: (id: SlotId) => Promise<ReactNode> | undefined,\n    setCachedElement: (id: SlotId, element: ReactNode) => Promise<ReactNode>,\n  ): Promise<ReactNode> => {\n    const id = SLICE_SLOT_ID_PREFIX + sliceConfig.id;\n    const cached = getCachedElement(id);\n    if (cached) {\n      return cached;\n    }\n    let element = await sliceConfig.renderer();\n    if (sliceConfig.isStatic) {\n      element = await setCachedElement(id, element);\n    }\n    return element;\n  };\n\n  const getEntriesForRoute = async (\n    rscPath: string,\n    rscParams: unknown,\n    headers: Readonly<Record<string, string>>,\n    getCachedElement: (id: SlotId) => Promise<ReactNode> | undefined,\n    setCachedElement: (id: SlotId, element: ReactNode) => Promise<ReactNode>,\n  ) => {\n    setRscPath(rscPath);\n    setRscParams(rscParams);\n    const pathname = decodeRoutePath(rscPath);\n    const pathConfigItem = await getPathConfigItem(pathname);\n    if (pathConfigItem?.type !== 'route') {\n      return null;\n    }\n    let skipParam: unknown;\n    try {\n      skipParam = JSON.parse(headers[SKIP_HEADER.toLowerCase()] || '');\n    } catch {\n      // ignore\n    }\n    const skipIdSet = new Set(isStringArray(skipParam) ? skipParam : []);\n    const { query } = parseRscParams(rscParams);\n    const decodedPathname = decodeURI(pathname);\n    const routeId = ROUTE_SLOT_ID_PREFIX + decodedPathname;\n    const option: RendererOption = {\n      pathname: decodedPathname,\n      query: pathConfigItem.isStatic ? undefined : query,\n    };\n    const myConfig = await getMyConfig();\n    const slices = pathConfigItem.slices || [];\n    const sliceConfigMap = new Map<\n      string,\n      { id: string; isStatic: boolean; renderer: () => Promise<ReactNode> }\n    >();\n    slices.forEach((sliceId) => {\n      const sliceConfig = myConfig.configs.find(\n        (item): item is typeof item & { type: 'slice' } =>\n          item.type === 'slice' && item.id === sliceId,\n      );\n      if (sliceConfig) {\n        sliceConfigMap.set(sliceId, sliceConfig);\n      }\n    });\n    const entries: Record<SlotId, unknown> = {};\n    await Promise.all([\n      (async () => {\n        if (!pathConfigItem.rootElement.isStatic) {\n          entries[ROOT_SLOT_ID] = pathConfigItem.rootElement.renderer(option);\n        } else if (!skipIdSet.has(ROOT_SLOT_ID)) {\n          const cached = getCachedElement(ROOT_SLOT_ID);\n          entries[ROOT_SLOT_ID] = cached\n            ? await cached\n            : await setCachedElement(\n                ROOT_SLOT_ID,\n                pathConfigItem.rootElement.renderer(option),\n              );\n        }\n      })(),\n      (async () => {\n        if (!pathConfigItem.routeElement.isStatic) {\n          entries[routeId] = pathConfigItem.routeElement.renderer(option);\n        } else if (!skipIdSet.has(routeId)) {\n          const cached = getCachedElement(routeId);\n          entries[routeId] = cached\n            ? await cached\n            : await setCachedElement(\n                routeId,\n                pathConfigItem.routeElement.renderer(option),\n              );\n        }\n      })(),\n      ...Object.entries(pathConfigItem.elements).map(\n        async ([id, { isStatic }]) => {\n          const renderer = pathConfigItem.elements[id]?.renderer;\n          if (!isStatic) {\n            entries[id] = renderer?.(option);\n          } else if (!skipIdSet.has(id)) {\n            const cached = getCachedElement(id);\n            entries[id] = cached\n              ? await cached\n              : await setCachedElement(id, renderer?.(option));\n          }\n        },\n      ),\n      ...slices.map(async (sliceId) => {\n        const id = SLICE_SLOT_ID_PREFIX + sliceId;\n        const sliceConfig = sliceConfigMap.get(sliceId);\n        if (!sliceConfig) {\n          throw new Error(`Slice not found: ${sliceId}`);\n        }\n        if (sliceConfig.isStatic && skipIdSet.has(id)) {\n          return null;\n        }\n        const sliceElement = await getSliceElement(\n          sliceConfig,\n          getCachedElement,\n          setCachedElement,\n        );\n        entries[id] = sliceElement;\n      }),\n    ]);\n    entries[ROUTE_ID] = [decodedPathname, query];\n    entries[IS_STATIC_ID] = pathConfigItem.isStatic;\n    sliceConfigMap.forEach((sliceConfig, sliceId) => {\n      if (sliceConfig.isStatic) {\n        // FIXME: hard-coded for now\n        entries[IS_STATIC_ID + ':' + SLICE_SLOT_ID_PREFIX + sliceId] = true;\n      }\n    });\n    if (myConfig.has404) {\n      entries[HAS404_ID] = true;\n    }\n    return entries;\n  };\n\n  type HandleRequest = Parameters<typeof defineHandlers>[0]['handleRequest'];\n  type HandleBuild = Parameters<typeof defineHandlers>[0]['handleBuild'];\n\n  const cachedElementsForRequest = new Map<SlotId, Promise<ReactNode>>();\n  let cachedElementsForRequestInitialized = false;\n  let cachedPath2moduleIds: Record<string, string[]> | undefined;\n\n  const handleRequest: HandleRequest = async (\n    input,\n    { renderRsc, parseRsc, renderHtml, loadBuildMetadata },\n  ): Promise<ReadableStream | Response | 'fallback' | null | undefined> => {\n    const getCachedElement = (id: SlotId) => cachedElementsForRequest.get(id);\n    const setCachedElement = (id: SlotId, element: ReactNode) => {\n      const cached = cachedElementsForRequest.get(id);\n      if (cached) {\n        return cached;\n      }\n      const copied = renderRsc({ [id]: element }).then((rscStream) =>\n        parseRsc(rscStream).then((parsed) => parsed[id]),\n      ) as Promise<ReactNode>;\n      cachedElementsForRequest.set(id, copied);\n      return copied;\n    };\n    if (!cachedElementsForRequestInitialized) {\n      cachedElementsForRequestInitialized = true;\n      const cachedElementsMetadata = await loadBuildMetadata(\n        'defineRouter:cachedElements',\n      );\n      if (cachedElementsMetadata) {\n        Object.entries(JSON.parse(cachedElementsMetadata)).forEach(\n          ([id, str]) => {\n            cachedElementsForRequest.set(\n              id,\n              parseRsc(base64ToStream(str as string)).then(\n                (parsed) => parsed[id],\n              ) as Promise<ReactNode>,\n            );\n          },\n        );\n      }\n    }\n    const getPath2moduleIds = async () => {\n      if (!cachedPath2moduleIds) {\n        cachedPath2moduleIds = JSON.parse(\n          (await loadBuildMetadata('defineRouter:path2moduleIds')) || '{}',\n        );\n      }\n      return cachedPath2moduleIds!;\n    };\n\n    const pathConfigItem = await getPathConfigItem(input.pathname);\n    if (pathConfigItem?.type === 'api') {\n      const url = new URL(input.req.url);\n      url.pathname = input.pathname;\n      const req = new Request(url, input.req);\n      return pathConfigItem.handler(req);\n    }\n\n    const url = new URL(input.req.url);\n    const headers = Object.fromEntries(input.req.headers.entries());\n    if (input.type === 'component') {\n      const sliceId = decodeSliceId(input.rscPath);\n      if (sliceId !== null) {\n        // LIMITATION: This is a signle slice request.\n        // Ideally, we should be able to respond with multiple slices in one request.\n        const sliceConfig = await getMyConfig().then((myConfig) =>\n          myConfig.configs.find(\n            (item): item is typeof item & { type: 'slice' } =>\n              item.type === 'slice' && item.id === sliceId,\n          ),\n        );\n        if (!sliceConfig) {\n          return null;\n        }\n        const sliceElement = await getSliceElement(\n          sliceConfig,\n          getCachedElement,\n          setCachedElement,\n        );\n        return renderRsc({\n          [SLICE_SLOT_ID_PREFIX + sliceId]: sliceElement,\n          ...(sliceConfig.isStatic\n            ? {\n                // FIXME: hard-coded for now\n                [IS_STATIC_ID + ':' + SLICE_SLOT_ID_PREFIX + sliceId]: true,\n              }\n            : {}),\n        });\n      }\n      const entries = await getEntriesForRoute(\n        input.rscPath,\n        input.rscParams,\n        headers,\n        getCachedElement,\n        setCachedElement,\n      );\n      if (!entries) {\n        return null;\n      }\n      return renderRsc(entries);\n    }\n\n    if (input.type === 'function') {\n      let elementsPromise: Promise<Record<string, unknown>> = Promise.resolve(\n        {},\n      );\n      let rendered = false;\n      const rerender = (rscPath: string, rscParams?: unknown) => {\n        if (rendered) {\n          throw new Error('already rendered');\n        }\n        elementsPromise = Promise.all([\n          elementsPromise,\n          getEntriesForRoute(\n            rscPath,\n            rscParams,\n            headers,\n            getCachedElement,\n            setCachedElement,\n          ),\n        ]).then(([oldElements, newElements]) => {\n          if (newElements === null) {\n            console.warn('getEntries returned null');\n          }\n          return {\n            ...oldElements,\n            ...newElements,\n          };\n        });\n      };\n      setRerender(rerender);\n      try {\n        const value = await input.fn(...input.args);\n        return renderRsc({ ...(await elementsPromise), _value: value });\n      } catch (e) {\n        const info = getErrorInfo(e);\n        if (info?.location) {\n          const rscPath = encodeRoutePath(info.location);\n          const entries = await getEntriesForRoute(\n            rscPath,\n            undefined,\n            headers,\n            getCachedElement,\n            setCachedElement,\n          );\n          if (!entries) {\n            unstable_notFound();\n          }\n          return renderRsc(entries);\n        }\n        throw e;\n      } finally {\n        rendered = true;\n      }\n    }\n\n    if (input.type === 'action' || input.type === 'custom') {\n      const renderIt = async (\n        pathname: string,\n        query: string,\n        httpstatus = 200,\n      ) => {\n        const rscPath = encodeRoutePath(pathname);\n        const rscParams = new URLSearchParams({ query });\n        const entries = await getEntriesForRoute(\n          rscPath,\n          rscParams,\n          headers,\n          getCachedElement,\n          setCachedElement,\n        );\n        if (!entries) {\n          return null;\n        }\n        const path2moduleIds = await getPath2moduleIds();\n        const html = (\n          <INTERNAL_ServerRouter\n            route={{ path: pathname, query, hash: '' }}\n            httpstatus={httpstatus}\n          />\n        );\n        const formState =\n          input.type === 'action' ? await input.fn() : undefined;\n        const nonce = getNonce();\n        return renderHtml(await renderRsc(entries), html, {\n          rscPath,\n          formState,\n          status: httpstatus,\n          ...(nonce ? { nonce } : {}),\n          unstable_extraScriptContent: getRouterPrefetchCode(path2moduleIds),\n        });\n      };\n      const query = url.searchParams.toString();\n      if (pathConfigItem?.type === 'route' && pathConfigItem.noSsr) {\n        return 'fallback';\n      }\n      try {\n        if (pathConfigItem) {\n          return await renderIt(input.pathname, query);\n        }\n      } catch (e) {\n        const info = getErrorInfo(e);\n        if (info?.status !== 404) {\n          throw e;\n        }\n      }\n      if ((await getMyConfig()).has404) {\n        return renderIt('/404', '', 404);\n      } else {\n        return null;\n      }\n    }\n  };\n\n  const handleBuild: HandleBuild = async ({\n    renderRsc,\n    parseRsc,\n    renderHtml,\n    rscPath2pathname,\n    saveBuildMetadata,\n    withRequest,\n    generateFile,\n    generateDefaultHtml,\n  }) => {\n    const myConfig = await getMyConfig();\n    const cachedElementsForBuild = new Map<SlotId, Promise<ReactNode>>();\n    const serializedCachedElements = new Map<SlotId, string>();\n    const getCachedElement = (id: SlotId) => cachedElementsForBuild.get(id);\n    const setCachedElement = async (id: SlotId, element: ReactNode) => {\n      const cached = cachedElementsForBuild.get(id);\n      if (cached) {\n        return cached;\n      }\n      const teedStream = renderRsc({ [id]: element }).then((rscStream) =>\n        rscStream.tee(),\n      );\n      const stream1 = teedStream.then(([s1]) => s1);\n      const stream2 = teedStream.then(([, s2]) => s2);\n      const copied = stream1.then(\n        (rscStream) =>\n          parseRsc(rscStream).then(\n            (parsed) => parsed[id],\n          ) as Promise<ReactNode>,\n      );\n      cachedElementsForBuild.set(id, copied);\n      serializedCachedElements.set(id, await streamToBase64(await stream2));\n      return copied;\n    };\n\n    // hard-coded concurrency limit\n    const { runTask, waitForTasks } = createTaskRunner(500);\n\n    // static api\n    for (const item of myConfig.configs) {\n      if (item.type !== 'api') {\n        continue;\n      }\n      if (!item.isStatic) {\n        continue;\n      }\n      const pathname = pathSpec2pathname(item.path);\n      if (!pathname) {\n        continue;\n      }\n      const req = new Request(new URL(pathname, 'http://localhost:3000'));\n      runTask(async () => {\n        await withRequest(req, async () => {\n          const res = await item.handler(req);\n          await generateFile(pathname, res.body || '');\n        });\n      });\n    }\n\n    const path2moduleIds: Record<string, string[]> = {};\n    const htmlRenderTasks = new Set<() => Promise<void>>();\n\n    // static route\n    for (const item of myConfig.configs) {\n      if (item.type !== 'route') {\n        continue;\n      }\n      if (!item.isStatic) {\n        continue;\n      }\n      const pathname = pathSpec2pathname(item.path);\n      if (!pathname) {\n        continue;\n      }\n      const rscPath = encodeRoutePath(pathname);\n      const req = new Request(new URL(pathname, 'http://localhost:3000'));\n      runTask(async () => {\n        await withRequest(req, async () => {\n          const entries = await getEntriesForRoute(\n            rscPath,\n            undefined,\n            {},\n            getCachedElement,\n            setCachedElement,\n          );\n          if (!entries) {\n            return;\n          }\n          for (const id of Object.keys(entries)) {\n            const cached = getCachedElement(id);\n            entries[id] = cached ? await cached : entries[id];\n          }\n          const moduleIds = new Set<string>();\n          const stream = await renderRsc(entries, {\n            unstable_clientModuleCallback: (ids) =>\n              ids.forEach((id) => moduleIds.add(id)),\n          });\n          const [stream1, stream2] = stream.tee();\n          await generateFile(rscPath2pathname(rscPath), stream1);\n          path2moduleIds[path2regexp(item.pathPattern || item.path)] =\n            Array.from(moduleIds);\n          htmlRenderTasks.add(async () => {\n            const html = (\n              <INTERNAL_ServerRouter\n                route={{ path: pathname, query: '', hash: '' }}\n                httpstatus={is404(item.path) ? 404 : 200}\n              />\n            );\n            const res = await renderHtml(stream2, html, {\n              rscPath,\n              unstable_extraScriptContent:\n                getRouterPrefetchCode(path2moduleIds),\n            });\n            await generateFile(htmlPath2pathname(pathname), res.body || '');\n          });\n        });\n      });\n    }\n    // HACK hopefully there is a better way than this\n    await waitForTasks();\n    htmlRenderTasks.forEach(runTask);\n\n    // default html\n    for (const item of myConfig.configs) {\n      if (item.type !== 'route') {\n        continue;\n      }\n      if (item.noSsr) {\n        const pathname = pathSpec2pathname(item.path);\n        if (!pathname) {\n          throw new Error('Pathname is required for noSsr routes on build');\n        }\n        runTask(async () => {\n          await generateDefaultHtml(htmlPath2pathname(pathname));\n        });\n      }\n    }\n\n    // static slice\n    for (const item of myConfig.configs) {\n      if (item.type !== 'slice') {\n        continue;\n      }\n      if (!item.isStatic) {\n        continue;\n      }\n      const rscPath = encodeSliceId(item.id);\n      // dummy req for slice which is not determined at build time\n      const req = new Request(new URL('http://localhost:3000'));\n      runTask(async () => {\n        await withRequest(req, async () => {\n          const sliceElement = await getSliceElement(\n            item,\n            getCachedElement,\n            setCachedElement,\n          );\n          const body = await renderRsc({\n            [SLICE_SLOT_ID_PREFIX + item.id]: sliceElement,\n            // FIXME: hard-coded for now\n            [IS_STATIC_ID + ':' + SLICE_SLOT_ID_PREFIX + item.id]: true,\n          });\n          await generateFile(rscPath2pathname(rscPath), body);\n        });\n      });\n    }\n\n    await waitForTasks();\n\n    // TODO should we save serialized cached elements separately?\n    await saveBuildMetadata(\n      'defineRouter:cachedElements',\n      JSON.stringify(Object.fromEntries(serializedCachedElements)),\n    );\n    await saveBuildMetadata(\n      'defineRouter:path2moduleIds',\n      JSON.stringify(path2moduleIds),\n    );\n  };\n\n  return Object.assign(defineHandlers({ handleRequest, handleBuild }), {\n    unstable_getRouterConfigs: () => getMyConfig().then((c) => c.configs),\n  });\n}\n"],"names":["createCustomError","getErrorInfo","getPathMapping","path2regexp","base64ToStream","streamToBase64","createTaskRunner","unstable_defineHandlers","defineHandlers","unstable_getContext","getContext","INTERNAL_ServerRouter","HAS404_ID","IS_STATIC_ID","ROUTE_ID","SKIP_HEADER","decodeRoutePath","decodeSliceId","encodeRoutePath","encodeSliceId","isStringArray","x","Array","isArray","every","y","parseRscParams","rscParams","URLSearchParams","query","get","RSC_PATH_SYMBOL","Symbol","RSC_PARAMS_SYMBOL","setRscPath","rscPath","context","setRscParams","unstable_getRscPath","undefined","unstable_getRscParams","getNonce","nonce","RERENDER_SYMBOL","setRerender","rerender","getRerender","is404","pathSpec","length","type","name","pathSpec2pathname","some","map","join","htmlPath2pathname","htmlPath","unstable_rerenderRoute","pathname","unstable_notFound","status","unstable_redirect","location","ROOT_SLOT_ID","ROUTE_SLOT_ID_PREFIX","SLICE_SLOT_ID_PREFIX","assertNonReservedSlotId","slotId","startsWith","Error","getRouterPrefetchCode","path2moduleIds","moduleIdSet","Set","Object","values","forEach","ids","id","add","from","path2idxs","entries","path","indexOf","JSON","stringify","unstable_defineRouter","fns","cachedMyConfig","getMyConfig","configs","getConfigs","has404","item","keys","elements","getPathConfigItem","myConfig","found","find","getSliceElement","sliceConfig","getCachedElement","setCachedElement","cached","element","renderer","isStatic","getEntriesForRoute","headers","pathConfigItem","skipParam","parse","toLowerCase","skipIdSet","decodedPathname","decodeURI","routeId","option","slices","sliceConfigMap","Map","sliceId","set","Promise","all","rootElement","has","routeElement","sliceElement","cachedElementsForRequest","cachedElementsForRequestInitialized","cachedPath2moduleIds","handleRequest","input","renderRsc","parseRsc","renderHtml","loadBuildMetadata","copied","then","rscStream","parsed","cachedElementsMetadata","str","getPath2moduleIds","url","URL","req","Request","handler","fromEntries","elementsPromise","resolve","rendered","oldElements","newElements","console","warn","value","fn","args","_value","e","info","renderIt","httpstatus","html","route","hash","formState","unstable_extraScriptContent","searchParams","toString","noSsr","handleBuild","rscPath2pathname","saveBuildMetadata","withRequest","generateFile","generateDefaultHtml","cachedElementsForBuild","serializedCachedElements","teedStream","tee","stream1","s1","stream2","s2","runTask","waitForTasks","res","body","htmlRenderTasks","moduleIds","stream","unstable_clientModuleCallback","pathPattern","assign","unstable_getRouterConfigs","c"],"mappings":"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"}