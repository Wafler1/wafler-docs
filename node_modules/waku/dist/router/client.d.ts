import { Component } from 'react';
import type { AnchorHTMLAttributes, ReactElement, ReactNode, Ref, TransitionFunction } from 'react';
import { addBase, removeBase } from '../lib/utils/path.js';
import type { RouteConfig } from './base-types.js';
import { encodeRoutePath, encodeSliceId } from './common.js';
import type { RouteProps } from './common.js';
type AllowPathDecorators<Path extends string> = Path extends unknown ? Path | `${Path}?${string}` | `${Path}#${string}` : never;
type InferredPaths = RouteConfig extends {
    paths: infer UserPaths extends string;
} ? AllowPathDecorators<UserPaths> : string;
type ChangeRoute = (route: RouteProps, options: {
    shouldScroll: boolean;
    skipRefetch?: boolean;
    unstable_startTransition?: ((fn: TransitionFunction) => void) | undefined;
}) => Promise<void>;
type ChangeRouteEvent = 'start' | 'complete';
type ChangeRouteCallback = (route: RouteProps) => void;
type PrefetchRoute = (route: RouteProps) => void;
type SliceId = string;
export declare function useRouter(): {
    push: (to: InferredPaths, options?: {
        /**
         * indicates if the link should scroll or not on navigation
         * - `true`: always scroll
         * - `false`: never scroll
         * - `undefined`: scroll on path change (not on searchParams change)
         */
        scroll?: boolean;
    }) => Promise<void>;
    replace: (to: InferredPaths, options?: {
        /**
         * indicates if the link should scroll or not on navigation
         * - `true`: always scroll
         * - `false`: never scroll
         * - `undefined`: scroll on path change (not on searchParams change)
         */
        scroll?: boolean;
    }) => Promise<void>;
    reload: () => Promise<void>;
    back: () => void;
    forward: () => void;
    prefetch: (to: string) => void;
    unstable_events: Record<"on" | "off", (event: ChangeRouteEvent, handler: ChangeRouteCallback) => void>;
    path: string;
    query: string;
    hash: string;
};
export type LinkProps = {
    to: InferredPaths;
    children: ReactNode;
    /**
     * indicates if the link should scroll or not on navigation
     * - `true`: always scroll
     * - `false`: never scroll
     * - `undefined`: scroll on path change (not on searchParams change)
     */
    scroll?: boolean;
    unstable_pending?: ReactNode;
    unstable_notPending?: ReactNode;
    unstable_prefetchOnEnter?: boolean;
    unstable_prefetchOnView?: boolean;
    unstable_startTransition?: ((fn: TransitionFunction) => void) | undefined;
    ref?: Ref<HTMLAnchorElement> | undefined;
} & Omit<AnchorHTMLAttributes<HTMLAnchorElement>, 'href'>;
export declare function Link({ to, children, scroll, unstable_pending, unstable_notPending, unstable_prefetchOnEnter, unstable_prefetchOnView, unstable_startTransition, ref: refProp, ...props }: LinkProps): ReactElement;
export declare class ErrorBoundary extends Component<{
    children: ReactNode;
}, {
    error?: unknown;
}> {
    constructor(props: {
        children: ReactNode;
    });
    static getDerivedStateFromError(error: unknown): {
        error: unknown;
    };
    render(): string | number | bigint | boolean | Iterable<ReactNode> | Promise<string | number | bigint | boolean | import("react").ReactPortal | ReactElement<unknown, string | import("react").JSXElementConstructor<any>> | Iterable<ReactNode> | null | undefined> | import("react/jsx-runtime").JSX.Element | null | undefined;
}
export declare function Slice({ id, children, ...props }: {
    id: SliceId;
    children?: ReactNode;
} & ({
    lazy?: false;
} | {
    lazy: true;
    fallback: ReactNode;
})): string | number | bigint | boolean | Iterable<ReactNode> | Promise<string | number | bigint | boolean | import("react").ReactPortal | ReactElement<unknown, string | import("react").JSXElementConstructor<any>> | Iterable<ReactNode> | null | undefined> | import("react/jsx-runtime").JSX.Element | null | undefined;
export declare function Router({ initialRoute, unstable_routeInterceptor, }: {
    initialRoute?: RouteProps;
    unstable_routeInterceptor?: (route: RouteProps) => RouteProps | false;
}): import("react/jsx-runtime").JSX.Element;
/**
 * ServerRouter for SSR
 * This is not a public API.
 */
export declare function INTERNAL_ServerRouter({ route, httpstatus, }: {
    route: RouteProps;
    httpstatus: number;
}): import("react/jsx-runtime").JSX.Element;
export type Unstable_RouteProps = RouteProps;
export declare const unstable_HAS404_ID = "HAS404";
export declare const unstable_IS_STATIC_ID = "IS_STATIC";
export declare const unstable_ROUTE_ID = "ROUTE";
export declare const unstable_SKIP_HEADER = "X-Waku-Router-Skip";
export declare const unstable_encodeRoutePath: typeof encodeRoutePath;
export declare const unstable_encodeSliceId: typeof encodeSliceId;
export declare const unstable_getRouteSlotId: (path: string) => string;
export declare const unstable_getSliceSlotId: (id: SliceId) => string;
export declare const unstable_getErrorInfo: (err: unknown) => {
    status?: number;
    location?: string;
} | null;
export declare const unstable_addBase: typeof addBase;
export declare const unstable_removeBase: typeof removeBase;
export declare const unstable_RouterContext: import("react").Context<{
    route: RouteProps;
    changeRoute: ChangeRoute;
    prefetchRoute: PrefetchRoute;
    routeChangeEvents: Record<"on" | "off", (event: ChangeRouteEvent, handler: ChangeRouteCallback) => void>;
    fetchingSlices: Set<SliceId>;
} | null>;
export type Unstable_ChangeRoute = ChangeRoute;
export type Unstable_ChangeRouteEvent = ChangeRouteEvent;
export type Unstable_ChangeRouteCallback = ChangeRouteCallback;
export type Unstable_PrefetchRoute = PrefetchRoute;
export type Unstable_SliceId = SliceId;
export type Unstable_InferredPaths = InferredPaths;
export declare const unstable_parseRoute: (url: URL) => RouteProps;
export declare const unstable_getHttpStatusFromMeta: () => string | undefined;
export {};
