import { IndexFilePlugin } from "./plugins/index-file.js";
import { z } from "zod";
import { Pluggable, Processor, Transformer } from "unified";
import * as Plugins from "fumadocs-core/mdx-plugins";
import { VFile } from "vfile";
import { ProcessorOptions } from "@mdx-js/mdx";
import { FSWatcher } from "chokidar";
import { StandardSchemaV1 } from "@standard-schema/spec";
import { Root } from "mdast";

//#region src/config/preset.d.ts
type ResolvePlugins = Pluggable[] | ((v: Pluggable[]) => Pluggable[]);
type DefaultMDXOptions = Omit<NonNullable<ProcessorOptions>, 'rehypePlugins' | 'remarkPlugins' | '_ctx'> & {
  rehypePlugins?: ResolvePlugins;
  remarkPlugins?: ResolvePlugins;
  /**
   * Properties to export from `vfile.data`
   */
  valueToExport?: string[];
  remarkStructureOptions?: Plugins.StructureOptions | false;
  remarkHeadingOptions?: Plugins.RemarkHeadingOptions;
  remarkImageOptions?: Plugins.RemarkImageOptions | false;
  remarkCodeTabOptions?: Plugins.RemarkCodeTabOptions | false;
  remarkNpmOptions?: Plugins.RemarkNpmOptions | false;
  rehypeCodeOptions?: Plugins.RehypeCodeOptions | false;
};
type MDXPresetOptions = ({
  preset?: 'fumadocs';
} & DefaultMDXOptions) | ({
  preset: 'minimal';
} & ProcessorOptions);
/**
 * apply MDX processor presets
 */
declare function applyMdxPreset(options?: MDXPresetOptions): (environment: BuildEnvironment) => Promise<ProcessorOptions>;
//#endregion
//#region ../core/dist/source/schema.d.ts
/**
* Zod 4 schema
*/
declare const metaSchema: z.ZodObject<{
  title: z.ZodOptional<z.ZodString>;
  pages: z.ZodOptional<z.ZodArray<z.ZodString>>;
  description: z.ZodOptional<z.ZodString>;
  root: z.ZodOptional<z.ZodBoolean>;
  defaultOpen: z.ZodOptional<z.ZodBoolean>;
  collapsible: z.ZodOptional<z.ZodBoolean>;
  icon: z.ZodOptional<z.ZodString>;
}, z.core.$strip>;
/**
* Zod 4 schema
*/
declare const pageSchema: z.ZodObject<{
  title: z.ZodString;
  description: z.ZodOptional<z.ZodString>;
  icon: z.ZodOptional<z.ZodString>;
  full: z.ZodOptional<z.ZodBoolean>;
  _openapi: z.ZodOptional<z.ZodObject<{}, z.core.$loose>>;
}, z.core.$strip>;
//#endregion
//#region src/loaders/mdx/remark-postprocess.d.ts
interface ExtractedReference {
  href: string;
}
interface PostprocessOptions {
  _format: 'md' | 'mdx';
  /**
   * Properties to export from `vfile.data`
   */
  valueToExport?: string[];
  /**
   * stringify MDAST and export via `_markdown`.
   */
  includeProcessedMarkdown?: boolean | {
    /**
     * include heading IDs into the processed markdown.
     */
    headingIds?: boolean;
  };
  /**
   * extract link references, export via `extractedReferences`.
   */
  extractLinkReferences?: boolean;
  /**
   * store MDAST and export via `_mdast`.
   */
  includeMDAST?: boolean | {
    removePosition?: boolean;
  };
}
//#endregion
//#region src/config/define.d.ts
type CollectionSchema<Schema extends StandardSchemaV1, Context> = Schema | ((ctx: Context) => Schema);
type AnyCollection = DocsCollection | DocCollection | MetaCollection;
interface BaseCollection {
  /**
   * Directory to scan
   */
  dir: string;
  /**
   * what files to include/exclude (glob patterns)
   *
   * Include all files if not specified
   */
  files?: string[];
}
interface MetaCollection<Schema extends StandardSchemaV1 = StandardSchemaV1> extends BaseCollection {
  type: 'meta';
  schema?: CollectionSchema<Schema, {
    path: string;
    source: string;
  }>;
}
interface DocCollection<Schema extends StandardSchemaV1 = StandardSchemaV1> extends BaseCollection {
  type: 'doc';
  postprocess?: Partial<PostprocessOptions>;
  mdxOptions?: ProcessorOptions | ((environment: BuildEnvironment) => Promise<ProcessorOptions>);
  /**
   * Load files with async
   */
  async?: boolean;
  /**
   * Compile files on-demand
   */
  dynamic?: boolean;
  schema?: CollectionSchema<Schema, {
    path: string;
    source: string;
  }>;
}
interface DocsCollection<DocSchema extends StandardSchemaV1 = StandardSchemaV1, MetaSchema extends StandardSchemaV1 = StandardSchemaV1> {
  type: 'docs';
  dir: string;
  docs: DocCollection<DocSchema>;
  meta: MetaCollection<MetaSchema>;
}
interface GlobalConfig {
  plugins?: PluginOption[];
  /**
   * Configure global MDX options
   */
  mdxOptions?: MDXPresetOptions | (() => Promise<MDXPresetOptions>);
  workspaces?: Record<string, {
    dir: string;
    config: Record<string, unknown>;
  }>;
  /**
   * specify a directory to access & store cache (disabled during development mode).
   *
   * The cache will never be updated, delete the cache folder to clean.
   */
  experimentalBuildCache?: string;
}
declare function defineCollections<Schema extends StandardSchemaV1 = StandardSchemaV1>(options: DocCollection<Schema>): DocCollection<Schema>;
declare function defineCollections<Schema extends StandardSchemaV1 = StandardSchemaV1>(options: MetaCollection<Schema>): MetaCollection<Schema>;
declare function defineDocs<DocSchema extends StandardSchemaV1 = typeof pageSchema, MetaSchema extends StandardSchemaV1 = typeof metaSchema>(options: {
  /**
   * The content directory to scan files
   *
   *  @defaultValue 'content/docs'
   */
  dir?: string;
  docs?: Omit<DocCollection<DocSchema>, 'dir' | 'type'>;
  meta?: Omit<MetaCollection<MetaSchema>, 'dir' | 'type'>;
}): DocsCollection<DocSchema, MetaSchema>;
declare function defineConfig(config?: GlobalConfig): GlobalConfig;
//#endregion
//#region src/config/build.d.ts
type BuildEnvironment = 'bundler' | 'runtime';
interface LoadedConfig {
  collections: Map<string, CollectionItem>;
  global: GlobalConfig;
  getMDXOptions(collection?: DocCollectionItem, environment?: BuildEnvironment): ProcessorOptions | Promise<ProcessorOptions>;
  workspaces: Record<string, {
    dir: string;
    config: LoadedConfig;
  }>;
}
type CollectionItem = MetaCollectionItem | DocCollectionItem | DocsCollectionItem;
interface PrimitiveCollectionItem {
  name: string;
  cwd: string;
  /**
   * content directory (absolute)
   */
  dir: string;
  hasFile: (filePath: string) => boolean;
  isFileSupported: (filePath: string) => boolean;
  patterns: string[];
}
type MetaCollectionItem = PrimitiveCollectionItem & Omit<MetaCollection, 'files' | 'dir'>;
type DocCollectionItem = PrimitiveCollectionItem & Omit<DocCollection, 'files' | 'dir'>;
interface DocsCollectionItem extends Omit<DocsCollection, 'dir' | 'meta' | 'docs'>, Omit<PrimitiveCollectionItem, 'patterns'> {
  meta: MetaCollectionItem;
  docs: DocCollectionItem;
}
//#endregion
//#region src/loaders/mdx/remark-include.d.ts
declare function remarkInclude(this: Processor): Transformer<Root, Root>;
//#endregion
//#region src/core.d.ts
type Awaitable<T> = T | Promise<T>;
interface EmitEntry {
  /**
   * path relative to output directory
   */
  path: string;
  content: string;
}
interface PluginContext {
  core: Core;
}
type CompilationContext<Collection> = PluginContext & TransformOptions<Collection>;
interface TransformOptions<Collection> {
  collection: Collection;
  filePath: string;
  source: string;
}
interface Plugin extends IndexFilePlugin {
  name?: string;
  /**
   * on config loaded/updated
   */
  config?: (this: PluginContext, config: LoadedConfig) => Awaitable<void | LoadedConfig>;
  /**
   * Generate files (e.g. types, index file, or JSON schemas)
   */
  emit?: (this: PluginContext) => Awaitable<EmitEntry[]>;
  /**
   * Configure Fumadocs dev server
   */
  configureServer?: (this: PluginContext, server: ServerContext) => Awaitable<void>;
  meta?: {
    /**
     * Transform metadata
     */
    transform?: (this: CompilationContext<MetaCollectionItem>, data: unknown) => Awaitable<unknown | void>;
  };
  doc?: {
    /**
     * Transform frontmatter
     */
    frontmatter?: (this: CompilationContext<DocCollectionItem>, data: Record<string, unknown>) => Awaitable<Record<string, unknown> | void>;
    /**
     * Transform `vfile` on compilation stage
     */
    vfile?: (this: CompilationContext<DocCollectionItem>, file: VFile) => Awaitable<VFile | void>;
  };
}
type PluginOption = Awaitable<Plugin | PluginOption[] | false | undefined>;
interface ServerContext {
  /**
   * the file watcher, by default all content files are watched, along with other files.
   *
   * make sure to filter when listening to events
   */
  watcher?: FSWatcher;
}
interface CoreOptions {
  environment: string;
  configPath: string;
  outDir: string;
  plugins?: PluginOption[];
  /**
   * the workspace info if this instance is created as a workspace
   */
  workspace?: {
    parent: Core;
    name: string;
    dir: string;
  };
}
interface EmitOptions {
  /**
   * filter the plugins to run emit
   */
  filterPlugin?: (plugin: Plugin) => boolean;
  /**
   * filter the workspaces to run emit
   */
  filterWorkspace?: (workspace: string) => boolean;
  /**
   * write files
   */
  write?: boolean;
}
interface EmitOutput {
  entries: EmitEntry[];
  workspaces: Record<string, EmitEntry[]>;
}
declare const _Defaults: {
  configPath: string;
  outDir: string;
};
declare function createCore(options: CoreOptions): {
  /**
   * Convenient cache store, reset when config changes
   */
  cache: Map<string, unknown>;
  init({
    config: newConfig
  }: {
    config: Awaitable<LoadedConfig>;
  }): Promise<void>;
  getWorkspaces(): Map<string, /*elided*/any>;
  getOptions(): CoreOptions;
  getConfig(): LoadedConfig;
  /**
   * The file path of compiled config file, the file may not exist (e.g. on Vite, or still compiling)
   */
  getCompiledConfigPath(): string;
  getPlugins(): Plugin[];
  getCollections(): CollectionItem[];
  getCollection(name: string): CollectionItem | undefined;
  getPluginContext(): PluginContext;
  initServer(server: ServerContext): Promise<void>;
  emit(emitOptions?: EmitOptions): Promise<EmitOutput>;
  transformMeta(options: TransformOptions<MetaCollectionItem>, data: unknown): Promise<unknown>;
  transformFrontmatter(options: TransformOptions<DocCollectionItem>, data: Record<string, unknown>): Promise<Record<string, unknown>>;
  transformVFile(options: TransformOptions<DocCollectionItem>, file: VFile): Promise<VFile>;
};
type Core = ReturnType<typeof createCore>;
//#endregion
export { MDXPresetOptions as A, defineConfig as C, metaSchema as D, PostprocessOptions as E, pageSchema as O, defineCollections as S, ExtractedReference as T, CollectionSchema as _, EmitOptions as a, GlobalConfig as b, PluginContext as c, TransformOptions as d, _Defaults as f, BaseCollection as g, AnyCollection as h, EmitEntry as i, applyMdxPreset as j, DefaultMDXOptions as k, PluginOption as l, remarkInclude as m, Core as n, EmitOutput as o, createCore as p, CoreOptions as r, Plugin as s, CompilationContext as t, ServerContext as u, DocCollection as v, defineDocs as w, MetaCollection as x, DocsCollection as y };
//# sourceMappingURL=core-CES68-08.d.ts.map