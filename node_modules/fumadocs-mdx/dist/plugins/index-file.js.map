{"version":3,"file":"index-file.js","names":[],"sources":["../../src/plugins/index-file.ts"],"sourcesContent":["import type { Core, CoreOptions, Plugin, PluginContext } from '@/core';\nimport type { CollectionItem, DocCollectionItem, MetaCollectionItem } from '@/config/build';\nimport path from 'path';\nimport { type CodeGen, createCodegen, ident, slash } from '@/utils/codegen';\nimport { glob } from 'tinyglobby';\nimport { createFSCache } from '@/utils/fs-cache';\nimport { createHash } from 'crypto';\nimport type { LazyEntry } from '@/runtime/dynamic';\nimport type { EmitEntry } from '@/core';\nimport { fumaMatter } from '@/utils/fuma-matter';\nimport type { ServerOptions } from '@/runtime/server';\n\nexport interface IndexFilePluginOptions {\n  target?: 'default' | 'vite';\n\n  /**\n   * add `.js` extensions to imports, needed for ESM without bundler resolution\n   */\n  addJsExtension?: boolean;\n\n  /**\n   * Generate entry point for browser\n   * @defaultValue true\n   */\n  browser?: boolean;\n\n  /**\n   * Generate entry point for dynamic compilation\n   * @defaultValue true\n   */\n  dynamic?: boolean;\n}\n\nexport interface IndexFilePlugin {\n  ['index-file']?: {\n    generateTypeConfig?: (this: PluginContext) => string | void;\n    serverOptions?: (this: PluginContext, options: ServerOptions) => void;\n  };\n}\n\ninterface FileGenContext {\n  core: Core;\n  workspace?: string;\n  codegen: CodeGen;\n  serverOptions: ServerOptions;\n  tc: string;\n}\n\nconst indexFileCache = createFSCache();\n\nexport default function indexFile(options: IndexFilePluginOptions = {}): Plugin {\n  const { target = 'default', addJsExtension, browser = true, dynamic = true } = options;\n  let dynamicCollections: CollectionItem[];\n\n  function isDynamic(collection: CollectionItem) {\n    return (\n      (collection.type === 'docs' && collection.docs.dynamic) ||\n      (collection.type === 'doc' && collection.dynamic)\n    );\n  }\n\n  function generateConfigs(core: Core): {\n    serverOptions: ServerOptions;\n    tc: string;\n  } {\n    const serverOptions: ServerOptions = {};\n    const typeConfigs: string[] = ['import(\"fumadocs-mdx/runtime/types\").InternalTypeConfig'];\n    const ctx = core.getPluginContext();\n\n    for (const plugin of core.getPlugins()) {\n      const indexFilePlugin = plugin['index-file'];\n      if (!indexFilePlugin) continue;\n\n      indexFilePlugin.serverOptions?.call(ctx, serverOptions);\n      const config = indexFilePlugin.generateTypeConfig?.call(ctx);\n      if (config) typeConfigs.push(config);\n    }\n\n    return {\n      serverOptions,\n      tc: typeConfigs.join(' & '),\n    };\n  }\n\n  return {\n    name: 'index-file',\n    config() {\n      dynamicCollections = this.core.getCollections().filter(isDynamic);\n    },\n    configureServer(server) {\n      if (!server.watcher) return;\n\n      server.watcher.on('all', async (event, file) => {\n        indexFileCache.delete(file);\n\n        // dynamic collections always require re-generation on change\n        if (dynamicCollections.length === 0) {\n          // vite uses `import.meta.glob`, no need to re-generate\n          if (target === 'vite') return;\n          // only re-generate when adding/deleting entries\n          if (target === 'default' && event === 'change') return;\n        }\n\n        const updatedCollection = this.core\n          .getCollections()\n          .find((collection) => collection.hasFile(file));\n\n        if (!updatedCollection) return;\n        if (!isDynamic(updatedCollection)) {\n          if (target === 'vite') return;\n          if (target === 'default' && event === 'change') return;\n        }\n\n        await this.core.emit({\n          filterPlugin: (plugin) => plugin.name === 'index-file',\n          filterWorkspace: () => false,\n          write: true,\n        });\n      });\n    },\n    async emit() {\n      const globCache = new Map<string, Promise<string[]>>();\n      const { workspace, outDir } = this.core.getOptions();\n      const { serverOptions, tc } = generateConfigs(this.core);\n      const toEmitEntry = async (\n        path: string,\n        content: (ctx: FileGenContext) => Promise<void>,\n      ): Promise<EmitEntry> => {\n        const codegen = createCodegen({\n          target,\n          outDir: outDir,\n          jsExtension: addJsExtension,\n          globCache,\n        });\n        await content({\n          core: this.core,\n          codegen,\n          serverOptions,\n          tc,\n          workspace: workspace?.name,\n        });\n        return {\n          path,\n          content: codegen.toString(),\n        };\n      };\n\n      const out: Promise<EmitEntry>[] = [toEmitEntry('server.ts', generateServerIndexFile)];\n\n      if (dynamic) out.push(toEmitEntry('dynamic.ts', generateDynamicIndexFile));\n\n      if (browser) out.push(toEmitEntry('browser.ts', generateBrowserIndexFile));\n\n      return await Promise.all(out);\n    },\n  };\n}\n\nasync function generateServerIndexFile(ctx: FileGenContext) {\n  const { core, codegen, serverOptions, tc } = ctx;\n  codegen.lines.push(\n    `import { server } from 'fumadocs-mdx/runtime/server';`,\n    `import type * as Config from '${codegen.formatImportPath(core.getOptions().configPath)}';`,\n    '',\n    `const create = server<typeof Config, ${tc}>(${JSON.stringify(serverOptions)});`,\n  );\n\n  async function generateCollectionObject(collection: CollectionItem): Promise<string | undefined> {\n    const base = getBase(collection);\n\n    switch (collection.type) {\n      case 'docs': {\n        if (collection.docs.dynamic) return;\n\n        if (collection.docs.async) {\n          const [metaGlob, headGlob, bodyGlob] = await Promise.all([\n            generateMetaCollectionGlob(ctx, collection.meta, true),\n            generateDocCollectionFrontmatterGlob(ctx, collection.docs, true),\n            generateDocCollectionGlob(ctx, collection.docs),\n          ]);\n\n          return `await create.docsLazy(\"${collection.name}\", \"${base}\", ${metaGlob}, ${headGlob}, ${bodyGlob})`;\n        }\n\n        const [metaGlob, docGlob] = await Promise.all([\n          generateMetaCollectionGlob(ctx, collection.meta, true),\n          generateDocCollectionGlob(ctx, collection.docs, true),\n        ]);\n\n        return `await create.docs(\"${collection.name}\", \"${base}\", ${metaGlob}, ${docGlob})`;\n      }\n      case 'doc':\n        if (collection.dynamic) return;\n\n        if (collection.async) {\n          const [headGlob, bodyGlob] = await Promise.all([\n            generateDocCollectionFrontmatterGlob(ctx, collection, true),\n            generateDocCollectionGlob(ctx, collection),\n          ]);\n\n          return `await create.docLazy(\"${collection.name}\", \"${base}\", ${headGlob}, ${bodyGlob})`;\n        }\n\n        return `await create.doc(\"${collection.name}\", \"${base}\", ${await generateDocCollectionGlob(\n          ctx,\n          collection,\n          true,\n        )})`;\n      case 'meta':\n        return `await create.meta(\"${collection.name}\", \"${base}\", ${await generateMetaCollectionGlob(\n          ctx,\n          collection,\n          true,\n        )})`;\n    }\n  }\n\n  await codegen.pushAsync(\n    core.getCollections().map(async (collection) => {\n      const obj = await generateCollectionObject(collection);\n      if (!obj) return;\n\n      return `\\nexport const ${collection.name} = ${obj};`;\n    }),\n  );\n}\n\nasync function generateDynamicIndexFile(ctx: FileGenContext) {\n  const { core, codegen, serverOptions, tc } = ctx;\n  const { configPath, environment, outDir } = core.getOptions();\n  // serializable config options\n  const partialOptions: CoreOptions = {\n    configPath,\n    environment,\n    outDir,\n  };\n  codegen.lines.push(\n    `import { dynamic } from 'fumadocs-mdx/runtime/dynamic';`,\n    `import * as Config from '${codegen.formatImportPath(configPath)}';`,\n    '',\n    `const create = await dynamic<typeof Config, ${tc}>(Config, ${JSON.stringify(partialOptions)}, ${JSON.stringify(serverOptions)});`,\n  );\n\n  async function generateCollectionObjectEntry(\n    collection: DocCollectionItem,\n    absolutePath: string,\n  ) {\n    const fullPath = path.relative(process.cwd(), absolutePath);\n    const content = await indexFileCache.read(fullPath).catch(() => '');\n    const parsed = fumaMatter(content);\n    const data = await core.transformFrontmatter(\n      {\n        collection,\n        filePath: fullPath,\n        source: content,\n      },\n      parsed.data as Record<string, unknown>,\n    );\n\n    const hash = createHash('md5').update(content).digest('hex');\n    const infoStr: string[] = [\n      // make sure it's included in vercel/nft\n      `absolutePath: path.resolve(${JSON.stringify(fullPath)})`,\n    ];\n    for (const [k, v] of Object.entries({\n      info: {\n        fullPath,\n        path: path.relative(collection.dir, absolutePath),\n      },\n      data,\n      hash,\n    } satisfies LazyEntry)) {\n      infoStr.push(`${k}: ${JSON.stringify(v)}`);\n    }\n\n    return `{ ${infoStr.join(', ')} }`;\n  }\n\n  async function generateCollectionObject(parent: CollectionItem): Promise<string | undefined> {\n    let collection: DocCollectionItem | undefined;\n    if (parent.type === 'doc') collection = parent;\n    else if (parent.type === 'docs') collection = parent.docs;\n\n    if (!collection || !collection.dynamic) return;\n\n    const files = await glob(collection.patterns, {\n      cwd: collection.dir,\n      absolute: true,\n    });\n    const entries = await Promise.all(\n      files.map((file) => generateCollectionObjectEntry(collection, file)),\n    );\n\n    switch (parent.type) {\n      case 'docs': {\n        const metaGlob = await generateMetaCollectionGlob(ctx, parent.meta, true);\n\n        return `await create.docs(\"${parent.name}\", \"${getBase(parent)}\", ${metaGlob}, ${entries.join(', ')})`;\n      }\n      case 'doc':\n        return `await create.doc(\"${collection.name}\", \"${getBase(collection)}\", ${entries.join(', ')})`;\n    }\n  }\n\n  await codegen.pushAsync(\n    core.getCollections().map(async (collection) => {\n      const obj = await generateCollectionObject(collection);\n      if (!obj) return;\n\n      return `\\nexport const ${collection.name} = ${obj};`;\n    }),\n  );\n}\n\nasync function generateBrowserIndexFile(ctx: FileGenContext) {\n  const { core, codegen, tc } = ctx;\n  codegen.lines.push(\n    `import { browser } from 'fumadocs-mdx/runtime/browser';`,\n    `import type * as Config from '${codegen.formatImportPath(core.getOptions().configPath)}';`,\n    '',\n    `const create = browser<typeof Config, ${tc}>();`,\n  );\n\n  async function generateCollectionObject(collection: CollectionItem): Promise<string | undefined> {\n    switch (collection.type) {\n      case 'docs': {\n        if (collection.docs.dynamic) return;\n\n        return generateCollectionObject(collection.docs);\n      }\n      case 'doc':\n        if (collection.dynamic) return;\n\n        return `create.doc(\"${collection.name}\", ${await generateDocCollectionGlob(ctx, collection)})`;\n    }\n  }\n\n  codegen.lines.push('const browserCollections = {');\n\n  await codegen.pushAsync(\n    core.getCollections().map(async (collection) => {\n      const obj = await generateCollectionObject(collection);\n      if (!obj) return;\n\n      return ident(`${collection.name}: ${obj},`);\n    }),\n  );\n\n  codegen.lines.push('};', 'export default browserCollections;');\n}\n\nfunction getBase(collection: CollectionItem) {\n  return slash(path.relative(process.cwd(), collection.dir));\n}\n\nfunction generateDocCollectionFrontmatterGlob(\n  { codegen, workspace }: FileGenContext,\n  collection: DocCollectionItem,\n  eager = false,\n) {\n  return codegen.generateGlobImport(collection.patterns, {\n    query: {\n      collection: collection.name,\n      only: 'frontmatter',\n      workspace,\n    },\n    import: 'frontmatter',\n    base: collection.dir,\n    eager,\n  });\n}\n\nfunction generateDocCollectionGlob(\n  { codegen, workspace }: FileGenContext,\n  collection: DocCollectionItem,\n  eager = false,\n) {\n  return codegen.generateGlobImport(collection.patterns, {\n    query: {\n      collection: collection.name,\n      workspace,\n    },\n    base: collection.dir,\n    eager,\n  });\n}\n\nfunction generateMetaCollectionGlob(\n  { codegen, workspace }: FileGenContext,\n  collection: MetaCollectionItem,\n  eager = false,\n) {\n  return codegen.generateGlobImport(collection.patterns, {\n    query: {\n      collection: collection.name,\n      workspace,\n    },\n    import: 'default',\n    base: collection.dir,\n    eager,\n  });\n}\n"],"mappings":"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"}