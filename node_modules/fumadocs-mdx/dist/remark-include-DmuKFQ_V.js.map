{"version":3,"file":"remark-include-DmuKFQ_V.js","names":["fs","path"],"sources":["../src/loaders/mdx/remark-unravel.ts","../src/loaders/mdx/mdast-utils.ts","../src/loaders/mdx/remark-include.ts"],"sourcesContent":["// from internal remark plugins in https://github.com/mdx-js/mdx/blob/main/packages/mdx/lib/plugin/remark-mark-and-unravel.js\n// we need to ensure consistency with MDX.js when parsing embed content in `remark-include`\nimport { visit } from 'unist-util-visit';\nimport type { Transformer } from 'unified';\nimport type { Root, RootContent } from 'mdast';\n\nexport function remarkMarkAndUnravel(): Transformer<Root, Root> {\n  return (tree) => {\n    visit(tree, function (node, index, parent) {\n      let offset = -1;\n      let all = true;\n      let oneOrMore = false;\n\n      if (parent && typeof index === 'number' && node.type === 'paragraph') {\n        const children = node.children;\n\n        while (++offset < children.length) {\n          const child = children[offset];\n\n          if (child.type === 'mdxJsxTextElement' || child.type === 'mdxTextExpression') {\n            oneOrMore = true;\n          } else if (child.type === 'text' && child.value.trim().length === 0) {\n            // Empty.\n          } else {\n            all = false;\n            break;\n          }\n        }\n\n        if (all && oneOrMore) {\n          offset = -1;\n          const newChildren: RootContent[] = [];\n\n          while (++offset < children.length) {\n            const child = children[offset];\n\n            if (child.type === 'mdxJsxTextElement') {\n              // @ts-expect-error: mutate because it is faster; content model is fine.\n              child.type = 'mdxJsxFlowElement';\n            }\n\n            if (child.type === 'mdxTextExpression') {\n              // @ts-expect-error: mutate because it is faster; content model is fine.\n              child.type = 'mdxFlowExpression';\n            }\n\n            if (child.type === 'text' && /^[\\t\\r\\n ]+$/.test(String(child.value))) {\n              // Empty.\n            } else {\n              newChildren.push(child);\n            }\n          }\n\n          parent.children.splice(index, 1, ...newChildren);\n          return index;\n        }\n      }\n    });\n  };\n}\n","import type { RootContent } from 'mdast';\n\nexport function flattenNode(node: RootContent): string {\n  if ('children' in node) return node.children.map((child) => flattenNode(child)).join('');\n\n  if ('value' in node) return node.value;\n\n  return '';\n}\n","import { type Processor, type Transformer, unified } from 'unified';\nimport { visit } from 'unist-util-visit';\nimport type { Code, Node, Root, RootContent } from 'mdast';\nimport * as path from 'node:path';\nimport * as fs from 'node:fs/promises';\nimport { fumaMatter } from '@/utils/fuma-matter';\nimport type { MdxJsxFlowElement, MdxJsxTextElement } from 'mdast-util-mdx-jsx';\nimport { remarkHeading } from 'fumadocs-core/mdx-plugins';\nimport { VFile } from 'vfile';\nimport type { Directives } from 'mdast-util-directive';\nimport { remarkMarkAndUnravel } from '@/loaders/mdx/remark-unravel';\nimport { flattenNode } from './mdast-utils';\n\n/**\n * VS Code–style region extraction\n * Adapted from VitePress:\n * https://github.com/vuejs/vitepress/blob/main/src/node/markdown/plugins/snippet.ts\n */\n\n// region marker regexes\nconst REGION_MARKERS = [\n  {\n    start: /^\\s*\\/\\/\\s*#?region\\b\\s*(.*?)\\s*$/,\n    end: /^\\s*\\/\\/\\s*#?endregion\\b\\s*(.*?)\\s*$/,\n  },\n  {\n    start: /^\\s*<!--\\s*#?region\\b\\s*(.*?)\\s*-->/,\n    end: /^\\s*<!--\\s*#?endregion\\b\\s*(.*?)\\s*-->/,\n  },\n  {\n    start: /^\\s*\\/\\*\\s*#region\\b\\s*(.*?)\\s*\\*\\//,\n    end: /^\\s*\\/\\*\\s*#endregion\\b\\s*(.*?)\\s*\\*\\//,\n  },\n  {\n    start: /^\\s*#[rR]egion\\b\\s*(.*?)\\s*$/,\n    end: /^\\s*#[eE]nd ?[rR]egion\\b\\s*(.*?)\\s*$/,\n  },\n  {\n    start: /^\\s*#\\s*#?region\\b\\s*(.*?)\\s*$/,\n    end: /^\\s*#\\s*#?endregion\\b\\s*(.*?)\\s*$/,\n  },\n  {\n    start: /^\\s*(?:--|::|@?REM)\\s*#region\\b\\s*(.*?)\\s*$/,\n    end: /^\\s*(?:--|::|@?REM)\\s*#endregion\\b\\s*(.*?)\\s*$/,\n  },\n  {\n    start: /^\\s*#pragma\\s+region\\b\\s*(.*?)\\s*$/,\n    end: /^\\s*#pragma\\s+endregion\\b\\s*(.*?)\\s*$/,\n  },\n  {\n    start: /^\\s*\\(\\*\\s*#region\\b\\s*(.*?)\\s*\\*\\)/,\n    end: /^\\s*\\(\\*\\s*#endregion\\b\\s*(.*?)\\s*\\*\\)/,\n  },\n];\n\nfunction dedent(lines: string[]): string {\n  const minIndent = lines.reduce((min, line) => {\n    const match = line.match(/^(\\s*)\\S/);\n    return match ? Math.min(min, match[1].length) : min;\n  }, Infinity);\n\n  return minIndent === Infinity\n    ? lines.join('\\n')\n    : lines.map((l) => l.slice(minIndent)).join('\\n');\n}\n\nfunction extractCodeRegion(content: string, regionName: string): string {\n  const lines = content.split('\\n');\n\n  for (let i = 0; i < lines.length; i++) {\n    for (const re of REGION_MARKERS) {\n      let match = re.start.exec(lines[i]);\n      if (match?.[1] !== regionName) continue;\n\n      let depth = 1;\n      const extractedLines: string[] = [];\n      for (let j = i + 1; j < lines.length; j++) {\n        match = re.start.exec(lines[j]);\n        if (match) {\n          depth++;\n          continue;\n        }\n\n        match = re.end.exec(lines[j]);\n        if (match) {\n          if (match[1] === regionName) depth = 0;\n          else if (match[1] === '') depth--;\n          else continue;\n\n          if (depth > 0) continue;\n          return dedent(extractedLines);\n        } else {\n          extractedLines.push(lines[j]);\n        }\n      }\n    }\n  }\n  throw new Error(`Region \"${regionName}\" not found`);\n}\n\nexport interface Params {\n  lang?: string;\n  meta?: string;\n}\n\nconst ElementLikeTypes: ElementLikeContent['type'][] = [\n  'mdxJsxFlowElement',\n  'mdxJsxTextElement',\n  'containerDirective',\n  'textDirective',\n  'leafDirective',\n];\ntype ElementLikeContent = MdxJsxFlowElement | MdxJsxTextElement | Directives;\n\nfunction isElementLike(node: Node): node is ElementLikeContent {\n  return ElementLikeTypes.includes(node.type as ElementLikeContent['type']);\n}\n\nfunction parseElementAttributes(\n  element: ElementLikeContent,\n): Record<string, string | null | undefined> {\n  if (Array.isArray(element.attributes)) {\n    const attributes: Record<string, string | null> = {};\n\n    for (const attr of element.attributes) {\n      if (\n        attr.type === 'mdxJsxAttribute' &&\n        (typeof attr.value === 'string' || attr.value === null)\n      ) {\n        attributes[attr.name] = attr.value;\n      }\n    }\n\n    return attributes;\n  }\n\n  return element.attributes ?? {};\n}\n\nfunction parseSpecifier(specifier: string): {\n  file: string;\n  section?: string;\n} {\n  const idx = specifier.lastIndexOf('#');\n  if (idx === -1) return { file: specifier };\n\n  return {\n    file: specifier.slice(0, idx),\n    section: specifier.slice(idx + 1),\n  };\n}\n\nfunction extractSection(root: Root, section: string): Root | undefined {\n  let nodes: RootContent[] | undefined;\n  let capturingHeadingContent = false;\n\n  visit(root, (node) => {\n    if (node.type === 'heading') {\n      if (capturingHeadingContent) {\n        return false;\n      }\n\n      if (node.data?.hProperties?.id === section) {\n        capturingHeadingContent = true;\n        nodes = [node];\n        return 'skip';\n      }\n\n      return;\n    }\n\n    if (capturingHeadingContent) {\n      nodes?.push(node as RootContent);\n      return 'skip';\n    }\n\n    if (isElementLike(node) && node.name === 'section') {\n      const attributes = parseElementAttributes(node);\n\n      if (attributes.id === section) {\n        nodes = node.children;\n        return false;\n      }\n    }\n  });\n\n  if (nodes)\n    return {\n      type: 'root',\n      children: nodes,\n    };\n}\n\nexport function remarkInclude(this: Processor): Transformer<Root, Root> {\n  const TagName = 'include';\n\n  const embedContent = async (\n    targetPath: string,\n    heading: string | undefined,\n    params: Params,\n    parent: VFile,\n  ) => {\n    const { _getProcessor = () => this, _compiler } = parent.data;\n    let content: string;\n    try {\n      content = (await fs.readFile(targetPath)).toString();\n    } catch (e) {\n      throw new Error(\n        `failed to read file ${targetPath}\\n${e instanceof Error ? e.message : String(e)}`,\n        { cause: e },\n      );\n    }\n\n    const ext = path.extname(targetPath);\n    _compiler?.addDependency(targetPath);\n    // For non-Markdown files, support VS Code–style region extraction\n    if (params.lang || (ext !== '.md' && ext !== '.mdx')) {\n      const lang = params.lang ?? ext.slice(1);\n      let value = content;\n      if (heading) {\n        value = extractCodeRegion(content, heading.trim());\n      }\n      return {\n        type: 'code',\n        lang,\n        meta: params.meta,\n        value,\n        data: {},\n      } satisfies Code;\n    }\n\n    const parser = _getProcessor(ext === '.mdx' ? 'mdx' : 'md');\n    const parsed = fumaMatter(content);\n    const targetFile = new VFile({\n      path: targetPath,\n      value: parsed.content,\n      data: {\n        ...parent.data,\n        frontmatter: parsed.data as Record<string, unknown>,\n      },\n    });\n    let mdast = parser.parse(targetFile) as Root;\n    const baseProcessor = unified().use(remarkMarkAndUnravel);\n\n    if (heading) {\n      // parse headings before extraction\n      const extracted = extractSection(await baseProcessor.use(remarkHeading).run(mdast), heading);\n      if (!extracted)\n        throw new Error(\n          `Cannot find section ${heading} in ${targetPath}, make sure you have encapsulated the section in a <section id=\"${heading}\"> tag, or a :::section directive with remark-directive configured.`,\n        );\n\n      mdast = extracted;\n    } else {\n      mdast = await baseProcessor.run(mdast);\n    }\n\n    await update(mdast, targetFile);\n    return mdast;\n  };\n\n  async function update(tree: Root, file: VFile) {\n    const queue: Promise<void>[] = [];\n\n    visit(tree, ElementLikeTypes, (_node, _, parent) => {\n      const node = _node as ElementLikeContent;\n      if (node.name !== TagName) return;\n\n      const specifier = flattenNode(node);\n      if (specifier.length === 0) return 'skip';\n\n      const attributes = parseElementAttributes(node);\n      const { file: relativePath, section } = parseSpecifier(specifier);\n      const targetPath = path.resolve('cwd' in attributes ? file.cwd : file.dirname!, relativePath);\n\n      queue.push(\n        embedContent(targetPath, section, attributes, file).then((replace) => {\n          Object.assign(parent && parent.type === 'paragraph' ? parent : node, replace);\n        }),\n      );\n\n      return 'skip';\n    });\n\n    await Promise.all(queue);\n  }\n\n  return async (tree, file) => {\n    await update(tree, file);\n  };\n}\n"],"mappings":"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"}