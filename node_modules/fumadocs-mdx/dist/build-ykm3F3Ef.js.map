{"version":3,"file":"build-ykm3F3Ef.js","names":[],"sources":["../src/config/build.ts"],"sourcesContent":["import type { ProcessorOptions } from '@mdx-js/mdx';\nimport type {\n  AnyCollection,\n  DocCollection,\n  DocsCollection,\n  GlobalConfig,\n  MetaCollection,\n} from '@/config/define';\nimport picomatch from 'picomatch';\nimport { applyMdxPreset } from '@/config/preset';\nimport path from 'node:path';\n\nexport type BuildEnvironment = 'bundler' | 'runtime';\n\nexport interface LoadedConfig {\n  collections: Map<string, CollectionItem>;\n  global: GlobalConfig;\n  getMDXOptions(\n    collection?: DocCollectionItem,\n    environment?: BuildEnvironment,\n  ): ProcessorOptions | Promise<ProcessorOptions>;\n  workspaces: Record<\n    string,\n    {\n      dir: string;\n      config: LoadedConfig;\n    }\n  >;\n}\n\nexport type CollectionItem = MetaCollectionItem | DocCollectionItem | DocsCollectionItem;\n\ninterface PrimitiveCollectionItem {\n  name: string;\n  cwd: string;\n  /**\n   * content directory (absolute)\n   */\n  dir: string;\n  hasFile: (filePath: string) => boolean;\n  isFileSupported: (filePath: string) => boolean;\n  patterns: string[];\n}\n\nexport type MetaCollectionItem = PrimitiveCollectionItem & Omit<MetaCollection, 'files' | 'dir'>;\nexport type DocCollectionItem = PrimitiveCollectionItem & Omit<DocCollection, 'files' | 'dir'>;\n\nexport interface DocsCollectionItem\n  extends Omit<DocsCollection, 'dir' | 'meta' | 'docs'>, Omit<PrimitiveCollectionItem, 'patterns'> {\n  meta: MetaCollectionItem;\n  docs: DocCollectionItem;\n}\n\nconst SupportedFormats = {\n  doc: ['mdx', 'md'],\n  meta: ['json', 'yaml'],\n};\n\nexport function buildCollection(\n  name: string,\n  collection: AnyCollection,\n  cwd: string,\n): CollectionItem {\n  if (collection.type === 'docs') {\n    return {\n      ...collection,\n      type: 'docs',\n      get dir() {\n        return this.docs.dir;\n      },\n      name,\n      meta: buildCollection(name, collection.meta, cwd) as MetaCollectionItem,\n      docs: buildCollection(name, collection.docs, cwd) as DocCollectionItem,\n      hasFile(filePath) {\n        return this.docs.hasFile(filePath) || this.meta.hasFile(filePath);\n      },\n      isFileSupported(filePath) {\n        return this.docs.isFileSupported(filePath) || this.meta.isFileSupported(filePath);\n      },\n      cwd,\n    };\n  }\n\n  return {\n    ...collection,\n    ...buildPrimitiveCollection(name, collection, cwd),\n  };\n}\n\nfunction buildPrimitiveCollection(\n  name: string,\n  config: DocCollection | MetaCollection,\n  cwd: string,\n): PrimitiveCollectionItem {\n  const supportedFormats = SupportedFormats[config.type];\n  const patterns = config.files ?? [`**/*.{${supportedFormats.join(',')}}`];\n  let matcher: picomatch.Matcher;\n\n  return {\n    dir: path.resolve(cwd, config.dir),\n    cwd,\n    name,\n    patterns,\n    isFileSupported(filePath) {\n      return supportedFormats.some((format) => filePath.endsWith(`.${format}`));\n    },\n    hasFile(filePath) {\n      if (!this.isFileSupported(filePath)) return false;\n\n      const relativePath = path.relative(this.dir, filePath);\n      if (relativePath.startsWith(`..${path.sep}`)) return false;\n\n      return (matcher ??= picomatch(patterns))(relativePath);\n    },\n  };\n}\n\nexport function buildConfig(config: Record<string, unknown>, cwd = process.cwd()): LoadedConfig {\n  const collections = new Map<string, CollectionItem>();\n  const loaded: GlobalConfig = {};\n\n  for (const [k, v] of Object.entries(config)) {\n    if (!v) {\n      continue;\n    }\n\n    if (typeof v === 'object' && 'type' in v) {\n      if (v.type === 'docs' || v.type === 'doc' || v.type === 'meta') {\n        collections.set(k, buildCollection(k, v as AnyCollection, cwd));\n        continue;\n      }\n    }\n\n    if (k === 'default' && v) {\n      Object.assign(loaded, v);\n      continue;\n    }\n\n    throw new Error(\n      `Unknown export \"${k}\", you can only export collections from source configuration file.`,\n    );\n  }\n\n  const mdxOptionsCache = new Map<string, ProcessorOptions | Promise<ProcessorOptions>>();\n  return {\n    global: loaded,\n    collections,\n    workspaces: Object.fromEntries(\n      Object.entries(loaded.workspaces ?? {}).map(([key, value]) => {\n        return [\n          key,\n          {\n            dir: value.dir,\n            config: buildConfig(value.config, path.resolve(cwd, value.dir)),\n          },\n        ];\n      }),\n    ),\n    getMDXOptions(collection, environment = 'bundler') {\n      const key = collection ? `${environment}:${collection.name}` : environment;\n      const cached = mdxOptionsCache.get(key);\n      if (cached) return cached;\n      let result: ProcessorOptions | Promise<ProcessorOptions>;\n\n      if (collection?.mdxOptions) {\n        const optionsFn = collection.mdxOptions;\n        result = typeof optionsFn === 'function' ? optionsFn(environment) : optionsFn;\n      } else {\n        result = (async () => {\n          const optionsFn = this.global.mdxOptions;\n          const options = typeof optionsFn === 'function' ? await optionsFn() : optionsFn;\n\n          return applyMdxPreset(options)(environment);\n        })();\n      }\n\n      mdxOptionsCache.set(key, result);\n      return result;\n    },\n  };\n}\n"],"mappings":";;;;;AAqDA,MAAM,mBAAmB;CACvB,KAAK,CAAC,OAAO,KAAK;CAClB,MAAM,CAAC,QAAQ,OAAO;CACvB;AAED,SAAgB,gBACd,MACA,YACA,KACgB;AAChB,KAAI,WAAW,SAAS,OACtB,QAAO;EACL,GAAG;EACH,MAAM;EACN,IAAI,MAAM;AACR,UAAO,KAAK,KAAK;;EAEnB;EACA,MAAM,gBAAgB,MAAM,WAAW,MAAM,IAAI;EACjD,MAAM,gBAAgB,MAAM,WAAW,MAAM,IAAI;EACjD,QAAQ,UAAU;AAChB,UAAO,KAAK,KAAK,QAAQ,SAAS,IAAI,KAAK,KAAK,QAAQ,SAAS;;EAEnE,gBAAgB,UAAU;AACxB,UAAO,KAAK,KAAK,gBAAgB,SAAS,IAAI,KAAK,KAAK,gBAAgB,SAAS;;EAEnF;EACD;AAGH,QAAO;EACL,GAAG;EACH,GAAG,yBAAyB,MAAM,YAAY,IAAI;EACnD;;AAGH,SAAS,yBACP,MACA,QACA,KACyB;CACzB,MAAM,mBAAmB,iBAAiB,OAAO;CACjD,MAAM,WAAW,OAAO,SAAS,CAAC,SAAS,iBAAiB,KAAK,IAAI,CAAC,GAAG;CACzE,IAAI;AAEJ,QAAO;EACL,KAAK,KAAK,QAAQ,KAAK,OAAO,IAAI;EAClC;EACA;EACA;EACA,gBAAgB,UAAU;AACxB,UAAO,iBAAiB,MAAM,WAAW,SAAS,SAAS,IAAI,SAAS,CAAC;;EAE3E,QAAQ,UAAU;AAChB,OAAI,CAAC,KAAK,gBAAgB,SAAS,CAAE,QAAO;GAE5C,MAAM,eAAe,KAAK,SAAS,KAAK,KAAK,SAAS;AACtD,OAAI,aAAa,WAAW,KAAK,KAAK,MAAM,CAAE,QAAO;AAErD,WAAQ,YAAY,UAAU,SAAS,EAAE,aAAa;;EAEzD;;AAGH,SAAgB,YAAY,QAAiC,MAAM,QAAQ,KAAK,EAAgB;CAC9F,MAAM,8BAAc,IAAI,KAA6B;CACrD,MAAM,SAAuB,EAAE;AAE/B,MAAK,MAAM,CAAC,GAAG,MAAM,OAAO,QAAQ,OAAO,EAAE;AAC3C,MAAI,CAAC,EACH;AAGF,MAAI,OAAO,MAAM,YAAY,UAAU,GACrC;OAAI,EAAE,SAAS,UAAU,EAAE,SAAS,SAAS,EAAE,SAAS,QAAQ;AAC9D,gBAAY,IAAI,GAAG,gBAAgB,GAAG,GAAoB,IAAI,CAAC;AAC/D;;;AAIJ,MAAI,MAAM,aAAa,GAAG;AACxB,UAAO,OAAO,QAAQ,EAAE;AACxB;;AAGF,QAAM,IAAI,MACR,mBAAmB,EAAE,oEACtB;;CAGH,MAAM,kCAAkB,IAAI,KAA2D;AACvF,QAAO;EACL,QAAQ;EACR;EACA,YAAY,OAAO,YACjB,OAAO,QAAQ,OAAO,cAAc,EAAE,CAAC,CAAC,KAAK,CAAC,KAAK,WAAW;AAC5D,UAAO,CACL,KACA;IACE,KAAK,MAAM;IACX,QAAQ,YAAY,MAAM,QAAQ,KAAK,QAAQ,KAAK,MAAM,IAAI,CAAC;IAChE,CACF;IACD,CACH;EACD,cAAc,YAAY,cAAc,WAAW;GACjD,MAAM,MAAM,aAAa,GAAG,YAAY,GAAG,WAAW,SAAS;GAC/D,MAAM,SAAS,gBAAgB,IAAI,IAAI;AACvC,OAAI,OAAQ,QAAO;GACnB,IAAI;AAEJ,OAAI,YAAY,YAAY;IAC1B,MAAM,YAAY,WAAW;AAC7B,aAAS,OAAO,cAAc,aAAa,UAAU,YAAY,GAAG;SAEpE,WAAU,YAAY;IACpB,MAAM,YAAY,KAAK,OAAO;AAG9B,WAAO,eAFS,OAAO,cAAc,aAAa,MAAM,WAAW,GAAG,UAExC,CAAC,YAAY;OACzC;AAGN,mBAAgB,IAAI,KAAK,OAAO;AAChC,UAAO;;EAEV"}