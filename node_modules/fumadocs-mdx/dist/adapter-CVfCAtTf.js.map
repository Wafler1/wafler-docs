{"version":3,"file":"adapter-CVfCAtTf.js","names":[],"sources":["../src/loaders/config.ts","../src/loaders/adapter.ts"],"sourcesContent":["import type { Core } from '@/core';\nimport fs from 'node:fs/promises';\n\nexport interface ConfigLoader {\n  getCore(): Promise<Core>;\n}\n\nexport function createStandaloneConfigLoader({\n  core,\n  buildConfig,\n  mode,\n}: {\n  /**\n   * core (not initialized)\n   */\n  core: Core;\n  buildConfig: boolean;\n  /**\n   * In dev mode, the config file is dynamically re-loaded when it's updated.\n   */\n  mode: 'dev' | 'production';\n}): ConfigLoader {\n  let prev:\n    | {\n        hash: string;\n        init: Promise<void>;\n      }\n    | undefined;\n\n  async function getConfigHash(): Promise<string> {\n    if (mode === 'production') return 'static';\n\n    const stats = await fs.stat(core.getOptions().configPath).catch(() => {\n      throw new Error('Cannot find config file');\n    });\n\n    return stats.mtime.getTime().toString();\n  }\n\n  return {\n    async getCore() {\n      const hash = await getConfigHash();\n      if (!prev || hash !== prev.hash) {\n        prev = {\n          hash,\n          init: (async () => {\n            const { loadConfig } = await import('../config/load-from-file');\n\n            await core.init({\n              config: loadConfig(core, buildConfig),\n            });\n          })(),\n        };\n      }\n\n      await prev.init;\n      return core;\n    },\n  };\n}\n\n/**\n * create config loader from initialized core\n */\nexport function createIntegratedConfigLoader(core: Core): ConfigLoader {\n  return {\n    async getCore() {\n      return core;\n    },\n  };\n}\n","import type { CompilerOptions } from '@/loaders/mdx/build-mdx';\nimport type { LoadFnOutput, LoadHook } from 'node:module';\nimport { fileURLToPath } from 'node:url';\nimport fs from 'node:fs/promises';\nimport type { TransformPluginContext } from 'rollup';\nimport type { Environment, TransformResult } from 'vite';\nimport { parse } from 'node:querystring';\nimport { ValidationError } from '@/utils/validation';\nimport type { LoaderContext } from 'webpack';\nimport { readFileSync } from 'node:fs';\n\nexport interface LoaderInput {\n  development: boolean;\n  compiler: CompilerOptions;\n\n  filePath: string;\n  query: Record<string, string | string[] | undefined>;\n  getSource: () => string | Promise<string>;\n}\n\nexport interface LoaderOutput {\n  code: string;\n  map?: unknown;\n\n  /**\n   * Only supported in Vite 8.\n   *\n   * Explicitly define the transformed module type, for unsupported environments, you need to consider the differences between each bundler.\n   */\n  moduleType?: 'js' | 'json';\n}\n\ntype Awaitable<T> = T | Promise<T>;\n\nexport interface Loader {\n  /**\n   * Filter file paths, the input can be either a file URL or file path.\n   *\n   * Must take resource query into consideration.\n   */\n  test?: RegExp;\n\n  /**\n   * Transform input into JavaScript.\n   *\n   * Returns:\n   * - `LoaderOutput`: JavaScript code & source map.\n   * - `null`: skip the loader. Fallback to default behaviour if possible, otherwise the adapter will try workarounds.\n   */\n  load: (input: LoaderInput) => Awaitable<LoaderOutput | null>;\n\n  bun?: {\n    /**\n     * 1. Bun doesn't allow `null` in loaders.\n     * 2. Bun requires sync result to support dynamic require().\n     */\n    load?: (source: string, input: LoaderInput) => Awaitable<Bun.OnLoadResult>;\n  };\n}\n\nexport function toNode(loader: Loader): LoadHook {\n  return async (url, _context, nextLoad): Promise<LoadFnOutput> => {\n    if (url.startsWith('file:///') && (!loader.test || loader.test.test(url))) {\n      const parsedUrl = new URL(url);\n      const filePath = fileURLToPath(parsedUrl);\n\n      const result = await loader.load({\n        filePath,\n        query: Object.fromEntries(parsedUrl.searchParams.entries()),\n        async getSource() {\n          return (await fs.readFile(filePath)).toString();\n        },\n        development: false,\n        compiler: {\n          addDependency() {},\n        },\n      });\n\n      if (result) {\n        return {\n          source: result.code,\n          format: 'module',\n          shortCircuit: true,\n        };\n      }\n    }\n\n    return nextLoad(url);\n  };\n}\n\nexport interface ViteLoader {\n  filter: (id: string) => boolean;\n\n  transform: (\n    this: TransformPluginContext,\n    value: string,\n    id: string,\n  ) => Promise<TransformResult | null>;\n}\n\nexport function toVite(loader: Loader): ViteLoader {\n  return {\n    filter(id) {\n      return !loader.test || loader.test.test(id);\n    },\n    async transform(value, id) {\n      // Vite doesn't expose the real context types\n      const environment = (this as unknown as { environment: Environment }).environment;\n      const [file, query = ''] = id.split('?', 2);\n\n      const result = await loader.load({\n        filePath: file,\n        query: parse(query),\n        getSource() {\n          return value;\n        },\n        development: environment.mode === 'dev',\n        compiler: {\n          addDependency: (file) => {\n            this.addWatchFile(file);\n          },\n        },\n      });\n\n      if (result === null) return null;\n      return {\n        code: result.code,\n        map: result.map as TransformResult['map'],\n        moduleType: result.moduleType,\n      };\n    },\n  };\n}\n\nexport type WebpackLoader = (\n  this: LoaderContext<unknown>,\n  source: string,\n  callback: LoaderContext<unknown>['callback'],\n) => Promise<void>;\n\n/**\n * need to handle the `test` regex in Webpack config instead.\n */\nexport function toWebpack(loader: Loader): WebpackLoader {\n  return async function (source, callback) {\n    try {\n      const result = await loader.load({\n        filePath: this.resourcePath,\n        query: parse(this.resourceQuery.slice(1)),\n        getSource() {\n          return source;\n        },\n        development: this.mode === 'development',\n        compiler: this,\n      });\n\n      if (result === null) {\n        callback(undefined, source);\n      } else {\n        callback(undefined, result.code, result.map as string);\n      }\n    } catch (error) {\n      if (error instanceof ValidationError) {\n        return callback(new Error(await error.toStringFormatted()));\n      }\n\n      if (!(error instanceof Error)) throw error;\n      callback(error);\n    }\n  };\n}\n\nexport function toBun(loader: Loader) {\n  function toResult(output: LoaderOutput | null): Bun.OnLoadResult {\n    // it errors, treat this as an exception\n    if (!output) return;\n\n    return {\n      contents: output.code,\n      loader: output.moduleType ?? 'js',\n    };\n  }\n\n  return (build: Bun.PluginBuilder) => {\n    // avoid using async here, because it will cause dynamic require() to fail\n    build.onLoad({ filter: loader.test ?? /.+/ }, (args) => {\n      const [filePath, query = ''] = args.path.split('?', 2);\n      const input: LoaderInput = {\n        async getSource() {\n          return Bun.file(filePath).text();\n        },\n        query: parse(query),\n        filePath,\n        development: false,\n        compiler: {\n          addDependency() {},\n        },\n      };\n\n      if (loader.bun?.load) {\n        return loader.bun.load(readFileSync(filePath).toString(), input);\n      }\n\n      const result = loader.load(input);\n      if (result instanceof Promise) {\n        return result.then(toResult);\n      }\n      return toResult(result);\n    });\n  };\n}\n"],"mappings":"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"}