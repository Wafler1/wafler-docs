import { t as applyMdxPreset } from "./preset-Y6J6llIV.js";
import path from "node:path";
import picomatch from "picomatch";

//#region src/config/build.ts
const SupportedFormats = {
	doc: ["mdx", "md"],
	meta: ["json", "yaml"]
};
function buildCollection(name, collection, cwd) {
	if (collection.type === "docs") return {
		...collection,
		type: "docs",
		get dir() {
			return this.docs.dir;
		},
		name,
		meta: buildCollection(name, collection.meta, cwd),
		docs: buildCollection(name, collection.docs, cwd),
		hasFile(filePath) {
			return this.docs.hasFile(filePath) || this.meta.hasFile(filePath);
		},
		isFileSupported(filePath) {
			return this.docs.isFileSupported(filePath) || this.meta.isFileSupported(filePath);
		},
		cwd
	};
	return {
		...collection,
		...buildPrimitiveCollection(name, collection, cwd)
	};
}
function buildPrimitiveCollection(name, config, cwd) {
	const supportedFormats = SupportedFormats[config.type];
	const patterns = config.files ?? [`**/*.{${supportedFormats.join(",")}}`];
	let matcher;
	return {
		dir: path.resolve(cwd, config.dir),
		cwd,
		name,
		patterns,
		isFileSupported(filePath) {
			return supportedFormats.some((format) => filePath.endsWith(`.${format}`));
		},
		hasFile(filePath) {
			if (!this.isFileSupported(filePath)) return false;
			const relativePath = path.relative(this.dir, filePath);
			if (relativePath.startsWith(`..${path.sep}`)) return false;
			return (matcher ??= picomatch(patterns))(relativePath);
		}
	};
}
function buildConfig(config, cwd = process.cwd()) {
	const collections = /* @__PURE__ */ new Map();
	const loaded = {};
	for (const [k, v] of Object.entries(config)) {
		if (!v) continue;
		if (typeof v === "object" && "type" in v) {
			if (v.type === "docs" || v.type === "doc" || v.type === "meta") {
				collections.set(k, buildCollection(k, v, cwd));
				continue;
			}
		}
		if (k === "default" && v) {
			Object.assign(loaded, v);
			continue;
		}
		throw new Error(`Unknown export "${k}", you can only export collections from source configuration file.`);
	}
	const mdxOptionsCache = /* @__PURE__ */ new Map();
	return {
		global: loaded,
		collections,
		workspaces: Object.fromEntries(Object.entries(loaded.workspaces ?? {}).map(([key, value]) => {
			return [key, {
				dir: value.dir,
				config: buildConfig(value.config, path.resolve(cwd, value.dir))
			}];
		})),
		getMDXOptions(collection, environment = "bundler") {
			const key = collection ? `${environment}:${collection.name}` : environment;
			const cached = mdxOptionsCache.get(key);
			if (cached) return cached;
			let result;
			if (collection?.mdxOptions) {
				const optionsFn = collection.mdxOptions;
				result = typeof optionsFn === "function" ? optionsFn(environment) : optionsFn;
			} else result = (async () => {
				const optionsFn = this.global.mdxOptions;
				return applyMdxPreset(typeof optionsFn === "function" ? await optionsFn() : optionsFn)(environment);
			})();
			mdxOptionsCache.set(key, result);
			return result;
		}
	};
}

//#endregion
export { buildConfig as t };
//# sourceMappingURL=build-ykm3F3Ef.js.map