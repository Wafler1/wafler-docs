{"version":3,"file":"core-B8ONGqXn.js","names":[],"sources":["../src/utils/validation.ts","../src/core.ts"],"sourcesContent":["import type { CollectionSchema } from '@/config';\nimport type { StandardSchemaV1 } from '@standard-schema/spec';\n\nexport class ValidationError extends Error {\n  title: string;\n  issues: readonly StandardSchemaV1.Issue[];\n\n  constructor(message: string, issues: readonly StandardSchemaV1.Issue[]) {\n    super(`${message}:\\n${issues.map((issue) => `  ${issue.path}: ${issue.message}`).join('\\n')}`);\n\n    this.title = message;\n    this.issues = issues;\n  }\n\n  async toStringFormatted() {\n    // Handle ESM/CJS interop: picocolors is a CJS module that exports via\n    // module.exports = createColors(). When dynamically imported in ESM context\n    // (e.g., Next.js 16 Turbopack), the exports are wrapped under .default\n    const picocolorsModule = await import('picocolors');\n    const picocolors = picocolorsModule.default ?? picocolorsModule;\n\n    return [\n      picocolors.bold(`[MDX] ${this.title}:`),\n      ...this.issues.map((issue) =>\n        picocolors.redBright(\n          `- ${picocolors.bold(issue.path?.join('.') ?? '*')}: ${issue.message}`,\n        ),\n      ),\n    ].join('\\n');\n  }\n}\n\nexport async function validate<Schema extends StandardSchemaV1, Context>(\n  schema: CollectionSchema<Schema, Context>,\n  data: unknown,\n  context: Context,\n  errorMessage: string,\n): Promise<StandardSchemaV1.InferOutput<Schema>> {\n  if (typeof schema === 'function' && !('~standard' in schema)) {\n    schema = schema(context);\n  }\n\n  if ('~standard' in schema) {\n    const result = await (schema as StandardSchemaV1)['~standard'].validate(data);\n\n    if (result.issues) {\n      throw new ValidationError(errorMessage, result.issues);\n    }\n\n    return result.value;\n  }\n\n  return data;\n}\n","import type {\n  CollectionItem,\n  DocCollectionItem,\n  LoadedConfig,\n  MetaCollectionItem,\n} from '@/config/build';\nimport path from 'node:path';\nimport fs from 'node:fs/promises';\nimport type { FSWatcher } from 'chokidar';\nimport { validate } from './utils/validation';\nimport type { VFile } from 'vfile';\nimport type { IndexFilePlugin } from './plugins/index-file';\nimport type { PostprocessOptions } from './config';\nimport { ident } from './utils/codegen';\n\ntype Awaitable<T> = T | Promise<T>;\n\nexport interface EmitEntry {\n  /**\n   * path relative to output directory\n   */\n  path: string;\n  content: string;\n}\n\nexport interface PluginContext {\n  core: Core;\n}\n\nexport type CompilationContext<Collection> = PluginContext & TransformOptions<Collection>;\n\nexport interface TransformOptions<Collection> {\n  collection: Collection;\n  filePath: string;\n  source: string;\n}\n\nexport interface Plugin extends IndexFilePlugin {\n  name?: string;\n\n  /**\n   * on config loaded/updated\n   */\n  config?: (this: PluginContext, config: LoadedConfig) => Awaitable<void | LoadedConfig>;\n\n  /**\n   * Generate files (e.g. types, index file, or JSON schemas)\n   */\n  emit?: (this: PluginContext) => Awaitable<EmitEntry[]>;\n\n  /**\n   * Configure Fumadocs dev server\n   */\n  configureServer?: (this: PluginContext, server: ServerContext) => Awaitable<void>;\n\n  meta?: {\n    /**\n     * Transform metadata\n     */\n    transform?: (\n      this: CompilationContext<MetaCollectionItem>,\n      data: unknown,\n    ) => Awaitable<unknown | void>;\n  };\n\n  doc?: {\n    /**\n     * Transform frontmatter\n     */\n    frontmatter?: (\n      this: CompilationContext<DocCollectionItem>,\n      data: Record<string, unknown>,\n    ) => Awaitable<Record<string, unknown> | void>;\n\n    /**\n     * Transform `vfile` on compilation stage\n     */\n    vfile?: (this: CompilationContext<DocCollectionItem>, file: VFile) => Awaitable<VFile | void>;\n  };\n}\n\nexport type PluginOption = Awaitable<Plugin | PluginOption[] | false | undefined>;\n\nexport interface ServerContext {\n  /**\n   * the file watcher, by default all content files are watched, along with other files.\n   *\n   * make sure to filter when listening to events\n   */\n  watcher?: FSWatcher;\n}\n\nexport interface CoreOptions {\n  environment: string;\n  configPath: string;\n  outDir: string;\n  plugins?: PluginOption[];\n\n  /**\n   * the workspace info if this instance is created as a workspace\n   */\n  workspace?: {\n    parent: Core;\n    name: string;\n    dir: string;\n  };\n}\n\nexport interface EmitOptions {\n  /**\n   * filter the plugins to run emit\n   */\n  filterPlugin?: (plugin: Plugin) => boolean;\n\n  /**\n   * filter the workspaces to run emit\n   */\n  filterWorkspace?: (workspace: string) => boolean;\n\n  /**\n   * write files\n   */\n  write?: boolean;\n}\n\nexport interface EmitOutput {\n  entries: EmitEntry[];\n  workspaces: Record<string, EmitEntry[]>;\n}\n\nexport const _Defaults = {\n  configPath: 'source.config.ts',\n  outDir: '.source',\n};\n\nasync function getPlugins(pluginOptions: PluginOption[]): Promise<Plugin[]> {\n  const plugins: Plugin[] = [];\n\n  for await (const option of pluginOptions) {\n    if (!option) continue;\n    if (Array.isArray(option)) plugins.push(...(await getPlugins(option)));\n    else plugins.push(option);\n  }\n\n  return plugins;\n}\n\nexport function createCore(options: CoreOptions) {\n  let config: LoadedConfig;\n  let plugins: Plugin[];\n  const workspaces = new Map<string, Core>();\n\n  async function transformMetadata<T>(\n    { collection, filePath, source }: TransformOptions<DocCollectionItem | MetaCollectionItem>,\n    data: unknown,\n  ): Promise<T> {\n    if (collection.schema) {\n      data = await validate(\n        collection.schema,\n        data,\n        { path: filePath, source },\n        collection.type === 'doc'\n          ? `invalid frontmatter in ${filePath}`\n          : `invalid data in ${filePath}`,\n      );\n    }\n\n    return data as T;\n  }\n\n  return {\n    /**\n     * Convenient cache store, reset when config changes\n     */\n    cache: new Map<string, unknown>(),\n    async init({ config: newConfig }: { config: Awaitable<LoadedConfig> }) {\n      config = await newConfig;\n      this.cache.clear();\n      workspaces.clear();\n      plugins = await getPlugins([postprocessPlugin(), options.plugins, config.global.plugins]);\n\n      for (const plugin of plugins) {\n        const out = await plugin.config?.call(this.getPluginContext(), config);\n        if (out) config = out;\n      }\n\n      // only support workspaces with max depth 1\n      if (!options.workspace) {\n        await Promise.all(\n          Object.entries(config.workspaces).map(async ([name, workspace]) => {\n            const core = createCore({\n              ...options,\n              outDir: path.join(options.outDir, name),\n              workspace: {\n                name,\n                parent: this,\n                dir: workspace.dir,\n              },\n            });\n            await core.init({ config: workspace.config });\n            workspaces.set(name, core);\n          }),\n        );\n      }\n    },\n    getWorkspaces() {\n      return workspaces;\n    },\n    getOptions() {\n      return options;\n    },\n    getConfig(): LoadedConfig {\n      return config;\n    },\n    /**\n     * The file path of compiled config file, the file may not exist (e.g. on Vite, or still compiling)\n     */\n    getCompiledConfigPath(): string {\n      return path.join(options.outDir, 'source.config.mjs');\n    },\n    getPlugins() {\n      return plugins;\n    },\n    getCollections(): CollectionItem[] {\n      return Array.from(config.collections.values());\n    },\n    getCollection(name: string): CollectionItem | undefined {\n      return config.collections.get(name);\n    },\n    getPluginContext(): PluginContext {\n      return {\n        core: this,\n      };\n    },\n    async initServer(server: ServerContext): Promise<void> {\n      const ctx = this.getPluginContext();\n      for (const plugin of plugins) {\n        await plugin.configureServer?.call(ctx, server);\n      }\n      for (const workspace of workspaces.values()) {\n        await workspace.initServer(server);\n      }\n    },\n    async emit(emitOptions: EmitOptions = {}): Promise<EmitOutput> {\n      const { filterPlugin, filterWorkspace, write = false } = emitOptions;\n      const start = performance.now();\n      const ctx = this.getPluginContext();\n      const added = new Set<string>();\n      const out: EmitOutput = {\n        entries: [],\n        workspaces: {},\n      };\n\n      for (const li of await Promise.all(\n        plugins.map((plugin) => {\n          if ((filterPlugin && !filterPlugin(plugin)) || !plugin.emit) return;\n          return plugin.emit.call(ctx);\n        }),\n      )) {\n        if (!li) continue;\n        for (const item of li) {\n          if (added.has(item.path)) continue;\n          out.entries.push(item);\n          added.add(item.path);\n        }\n      }\n\n      if (write) {\n        await Promise.all(\n          out.entries.map(async (entry) => {\n            const file = path.join(options.outDir, entry.path);\n\n            await fs.mkdir(path.dirname(file), { recursive: true });\n            await fs.writeFile(file, entry.content);\n          }),\n        );\n\n        console.log(\n          options.workspace\n            ? `[MDX: ${options.workspace.name}] generated files in ${performance.now() - start}ms`\n            : `[MDX] generated files in ${performance.now() - start}ms`,\n        );\n      }\n\n      for (const [name, workspace] of workspaces) {\n        if (filterWorkspace && !filterWorkspace(name)) continue;\n        out.workspaces[name] = (await workspace.emit(emitOptions)).entries;\n      }\n\n      return out;\n    },\n    async transformMeta(\n      options: TransformOptions<MetaCollectionItem>,\n      data: unknown,\n    ): Promise<unknown> {\n      const ctx = {\n        ...this.getPluginContext(),\n        ...options,\n      };\n\n      data = await transformMetadata(options, data);\n      for (const plugin of plugins) {\n        if (plugin.meta?.transform) data = (await plugin.meta.transform.call(ctx, data)) ?? data;\n      }\n\n      return data;\n    },\n    async transformFrontmatter(\n      options: TransformOptions<DocCollectionItem>,\n      data: Record<string, unknown>,\n    ): Promise<Record<string, unknown>> {\n      const ctx = {\n        ...this.getPluginContext(),\n        ...options,\n      };\n\n      data = await transformMetadata(options, data);\n      for (const plugin of plugins) {\n        if (plugin.doc?.frontmatter) data = (await plugin.doc.frontmatter.call(ctx, data)) ?? data;\n      }\n\n      return data;\n    },\n    async transformVFile(\n      options: TransformOptions<DocCollectionItem>,\n      file: VFile,\n    ): Promise<VFile> {\n      const ctx = {\n        ...this.getPluginContext(),\n        ...options,\n      };\n\n      for (const plugin of plugins) {\n        if (plugin.doc?.vfile) file = (await plugin.doc.vfile.call(ctx, file)) ?? file;\n      }\n\n      return file;\n    },\n  };\n}\n\nfunction postprocessPlugin(): Plugin {\n  const LinkReferenceTypes = `{\n  /**\n   * extracted references (e.g. hrefs, paths), useful for analyzing relationships between pages.\n   */\n  extractedReferences: import(\"fumadocs-mdx\").ExtractedReference[];\n}`;\n\n  return {\n    'index-file': {\n      generateTypeConfig() {\n        const lines: string[] = [];\n        lines.push('{');\n        lines.push('  DocData: {');\n        for (const collection of this.core.getCollections()) {\n          let postprocessOptions: Partial<PostprocessOptions> | undefined;\n          switch (collection.type) {\n            case 'doc':\n              postprocessOptions = collection.postprocess;\n              break;\n            case 'docs':\n              postprocessOptions = collection.docs.postprocess;\n              break;\n          }\n\n          if (postprocessOptions?.extractLinkReferences) {\n            lines.push(ident(`${collection.name}: ${LinkReferenceTypes},`, 2));\n          }\n        }\n        lines.push('  }');\n        lines.push('}');\n        return lines.join('\\n');\n      },\n      serverOptions(options) {\n        options.doc ??= {};\n        options.doc.passthroughs ??= [];\n        options.doc.passthroughs.push('extractedReferences');\n      },\n    },\n  };\n}\n\nexport type Core = ReturnType<typeof createCore>;\n"],"mappings":"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"}