import { r as ValidationError } from "./core-B8ONGqXn.js";
import { readFileSync } from "node:fs";
import fs from "node:fs/promises";
import { fileURLToPath } from "node:url";
import { parse } from "node:querystring";

//#region src/loaders/config.ts
function createStandaloneConfigLoader({ core, buildConfig, mode }) {
	let prev;
	async function getConfigHash() {
		if (mode === "production") return "static";
		return (await fs.stat(core.getOptions().configPath).catch(() => {
			throw new Error("Cannot find config file");
		})).mtime.getTime().toString();
	}
	return { async getCore() {
		const hash = await getConfigHash();
		if (!prev || hash !== prev.hash) prev = {
			hash,
			init: (async () => {
				const { loadConfig } = await import("./load-from-file-XmVvZrXG.js").then((n) => n.n);
				await core.init({ config: loadConfig(core, buildConfig) });
			})()
		};
		await prev.init;
		return core;
	} };
}
/**
* create config loader from initialized core
*/
function createIntegratedConfigLoader(core) {
	return { async getCore() {
		return core;
	} };
}

//#endregion
//#region src/loaders/adapter.ts
function toNode(loader) {
	return async (url, _context, nextLoad) => {
		if (url.startsWith("file:///") && (!loader.test || loader.test.test(url))) {
			const parsedUrl = new URL(url);
			const filePath = fileURLToPath(parsedUrl);
			const result = await loader.load({
				filePath,
				query: Object.fromEntries(parsedUrl.searchParams.entries()),
				async getSource() {
					return (await fs.readFile(filePath)).toString();
				},
				development: false,
				compiler: { addDependency() {} }
			});
			if (result) return {
				source: result.code,
				format: "module",
				shortCircuit: true
			};
		}
		return nextLoad(url);
	};
}
function toVite(loader) {
	return {
		filter(id) {
			return !loader.test || loader.test.test(id);
		},
		async transform(value, id) {
			const environment = this.environment;
			const [file, query = ""] = id.split("?", 2);
			const result = await loader.load({
				filePath: file,
				query: parse(query),
				getSource() {
					return value;
				},
				development: environment.mode === "dev",
				compiler: { addDependency: (file) => {
					this.addWatchFile(file);
				} }
			});
			if (result === null) return null;
			return {
				code: result.code,
				map: result.map,
				moduleType: result.moduleType
			};
		}
	};
}
/**
* need to handle the `test` regex in Webpack config instead.
*/
function toWebpack(loader) {
	return async function(source, callback) {
		try {
			const result = await loader.load({
				filePath: this.resourcePath,
				query: parse(this.resourceQuery.slice(1)),
				getSource() {
					return source;
				},
				development: this.mode === "development",
				compiler: this
			});
			if (result === null) callback(void 0, source);
			else callback(void 0, result.code, result.map);
		} catch (error) {
			if (error instanceof ValidationError) return callback(new Error(await error.toStringFormatted()));
			if (!(error instanceof Error)) throw error;
			callback(error);
		}
	};
}
function toBun(loader) {
	function toResult(output) {
		if (!output) return;
		return {
			contents: output.code,
			loader: output.moduleType ?? "js"
		};
	}
	return (build) => {
		build.onLoad({ filter: loader.test ?? /.+/ }, (args) => {
			const [filePath, query = ""] = args.path.split("?", 2);
			const input = {
				async getSource() {
					return Bun.file(filePath).text();
				},
				query: parse(query),
				filePath,
				development: false,
				compiler: { addDependency() {} }
			};
			if (loader.bun?.load) return loader.bun.load(readFileSync(filePath).toString(), input);
			const result = loader.load(input);
			if (result instanceof Promise) return result.then(toResult);
			return toResult(result);
		});
	};
}

//#endregion
export { createIntegratedConfigLoader as a, toWebpack as i, toNode as n, createStandaloneConfigLoader as o, toVite as r, toBun as t };
//# sourceMappingURL=adapter-CVfCAtTf.js.map