{"version":3,"file":"server.js","names":["path"],"sources":["../../src/runtime/server.ts"],"sourcesContent":["import type { MetaData, PageData, Source, VirtualFile } from 'fumadocs-core/source';\nimport * as path from 'node:path';\nimport type { DocCollection, DocsCollection, MetaCollection } from '@/config';\nimport type { StandardSchemaV1 } from '@standard-schema/spec';\nimport type { CompiledMDXProperties } from '@/loaders/mdx/build-mdx';\nimport type { InternalTypeConfig, DocData, DocMethods, FileInfo, MetaMethods } from './types';\n\nexport type MetaCollectionEntry<Data> = Data & MetaMethods;\n\nexport type DocCollectionEntry<\n  Name extends string = string,\n  Frontmatter = unknown,\n  TC extends InternalTypeConfig = InternalTypeConfig,\n> = DocData & DocMethods & Frontmatter & TC['DocData'][Name];\n\nexport type AsyncDocCollectionEntry<\n  Name extends string = string,\n  Frontmatter = unknown,\n  TC extends InternalTypeConfig = InternalTypeConfig,\n> = {\n  load: () => Promise<DocData & TC['DocData'][Name]>;\n} & DocMethods &\n  Frontmatter;\n\nexport interface DocsCollectionEntry<\n  Name extends string = string,\n  Frontmatter extends PageData = PageData,\n  Meta extends MetaData = MetaData,\n  TC extends InternalTypeConfig = InternalTypeConfig,\n> {\n  docs: DocCollectionEntry<Name, Frontmatter, TC>[];\n  meta: MetaCollectionEntry<Meta>[];\n  toFumadocsSource: () => Source<{\n    pageData: DocCollectionEntry<Name, Frontmatter, TC>;\n    metaData: MetaCollectionEntry<Meta>;\n  }>;\n}\n\nexport interface AsyncDocsCollectionEntry<\n  Name extends string = string,\n  Frontmatter extends PageData = PageData,\n  Meta extends MetaData = MetaData,\n  TC extends InternalTypeConfig = InternalTypeConfig,\n> {\n  docs: AsyncDocCollectionEntry<Name, Frontmatter, TC>[];\n  meta: MetaCollectionEntry<Meta>[];\n  toFumadocsSource: () => Source<{\n    pageData: AsyncDocCollectionEntry<Name, Frontmatter, TC>;\n    metaData: MetaCollectionEntry<Meta>;\n  }>;\n}\n\ntype AwaitableGlobEntries<T> = Record<string, T | (() => Promise<T>)>;\n\nexport type ServerCreate<Config, TC extends InternalTypeConfig = InternalTypeConfig> = ReturnType<\n  typeof server<Config, TC>\n>;\n\nexport interface ServerOptions {\n  doc?: {\n    passthroughs?: string[];\n  };\n}\n\nexport function server<Config, TC extends InternalTypeConfig>(options: ServerOptions = {}) {\n  const { doc: { passthroughs: docPassthroughs = [] } = {} } = options;\n\n  function fileInfo(file: string, base: string): FileInfo {\n    if (file.startsWith('./')) {\n      file = file.slice(2);\n    }\n\n    return {\n      path: file,\n      fullPath: path.join(base, file),\n    };\n  }\n\n  function mapDocData(entry: CompiledMDXProperties): DocData {\n    const data: DocData = {\n      body: entry.default,\n      toc: entry.toc,\n      structuredData: entry.structuredData,\n      _exports: entry as unknown as Record<string, unknown>,\n    };\n\n    for (const key of docPassthroughs) {\n      // @ts-expect-error -- handle passthrough properties\n      data[key] = entry[key];\n    }\n\n    return data;\n  }\n\n  return {\n    async doc<Name extends keyof Config & string>(\n      _name: Name,\n      base: string,\n      glob: AwaitableGlobEntries<unknown>,\n    ) {\n      const out = await Promise.all(\n        Object.entries(glob).map(async ([k, v]) => {\n          const data: CompiledMDXProperties = typeof v === 'function' ? await v() : v;\n\n          return {\n            ...mapDocData(data),\n            ...(data.frontmatter as object),\n            ...createDocMethods(fileInfo(k, base), () => data),\n          } satisfies DocCollectionEntry;\n        }),\n      );\n\n      return out as unknown as Config[Name] extends\n        | DocCollection<infer Schema>\n        | DocsCollection<infer Schema>\n        ? DocCollectionEntry<Name, StandardSchemaV1.InferOutput<Schema>, TC>[]\n        : never;\n    },\n    async docLazy<Name extends keyof Config & string>(\n      _name: Name,\n      base: string,\n      head: AwaitableGlobEntries<unknown>,\n      body: Record<string, () => Promise<unknown>>,\n    ) {\n      const out = await Promise.all(\n        Object.entries(head).map(async ([k, v]) => {\n          const data = typeof v === 'function' ? await v() : v;\n          const content = body[k] as () => Promise<CompiledMDXProperties>;\n\n          return {\n            ...data,\n            ...createDocMethods(fileInfo(k, base), content),\n            async load() {\n              return mapDocData(await content());\n            },\n          } satisfies AsyncDocCollectionEntry;\n        }),\n      );\n\n      return out as unknown as Config[Name] extends\n        | DocCollection<infer Schema>\n        | DocsCollection<infer Schema>\n        ? AsyncDocCollectionEntry<Name, StandardSchemaV1.InferOutput<Schema>, TC>[]\n        : never;\n    },\n    async meta<Name extends keyof Config & string>(\n      _name: Name,\n      base: string,\n      glob: AwaitableGlobEntries<unknown>,\n    ) {\n      const out = await Promise.all(\n        Object.entries(glob).map(async ([k, v]) => {\n          const data = typeof v === 'function' ? await v() : v;\n\n          return {\n            info: fileInfo(k, base),\n            ...data,\n          } satisfies MetaCollectionEntry<unknown>;\n        }),\n      );\n\n      return out as unknown as Config[Name] extends\n        | MetaCollection<infer Schema>\n        | DocsCollection<StandardSchemaV1, infer Schema>\n        ? MetaCollectionEntry<StandardSchemaV1.InferOutput<Schema>>[]\n        : never;\n    },\n\n    async docs<Name extends keyof Config & string>(\n      name: Name,\n      base: string,\n      metaGlob: AwaitableGlobEntries<unknown>,\n      docGlob: AwaitableGlobEntries<unknown>,\n    ) {\n      const entry = {\n        docs: await this.doc(name, base, docGlob),\n        meta: await this.meta(name, base, metaGlob),\n        toFumadocsSource() {\n          return toFumadocsSource(this.docs, this.meta);\n        },\n      } satisfies DocsCollectionEntry;\n\n      return entry as Config[Name] extends DocsCollection<infer Page, infer Meta>\n        ? StandardSchemaV1.InferOutput<Page> extends PageData\n          ? StandardSchemaV1.InferOutput<Meta> extends MetaData\n            ? DocsCollectionEntry<\n                Name,\n                StandardSchemaV1.InferOutput<Page>,\n                StandardSchemaV1.InferOutput<Meta>,\n                TC\n              >\n            : never\n          : never\n        : never;\n    },\n    async docsLazy<Name extends keyof Config & string>(\n      name: Name,\n      base: string,\n      metaGlob: AwaitableGlobEntries<unknown>,\n      docHeadGlob: AwaitableGlobEntries<unknown>,\n      docBodyGlob: Record<string, () => Promise<unknown>>,\n    ) {\n      const entry = {\n        docs: await this.docLazy(name, base, docHeadGlob, docBodyGlob),\n        meta: await this.meta(name, base, metaGlob),\n        toFumadocsSource() {\n          return toFumadocsSource(this.docs, this.meta);\n        },\n      } satisfies AsyncDocsCollectionEntry;\n\n      return entry as Config[Name] extends DocsCollection<infer Page, infer Meta>\n        ? StandardSchemaV1.InferOutput<Page> extends PageData\n          ? StandardSchemaV1.InferOutput<Meta> extends MetaData\n            ? AsyncDocsCollectionEntry<\n                Name,\n                StandardSchemaV1.InferOutput<Page>,\n                StandardSchemaV1.InferOutput<Meta>,\n                TC\n              >\n            : never\n          : never\n        : never;\n    },\n  };\n}\n\nexport function toFumadocsSource<\n  Page extends DocMethods & PageData,\n  Meta extends MetaMethods & MetaData,\n>(\n  pages: Page[],\n  metas: Meta[],\n): Source<{\n  pageData: Page;\n  metaData: Meta;\n}> {\n  const files: VirtualFile<{\n    pageData: Page;\n    metaData: Meta;\n  }>[] = [];\n\n  for (const entry of pages) {\n    files.push({\n      type: 'page',\n      path: entry.info.path,\n      absolutePath: entry.info.fullPath,\n      data: entry,\n    });\n  }\n\n  for (const entry of metas) {\n    files.push({\n      type: 'meta',\n      path: entry.info.path,\n      absolutePath: entry.info.fullPath,\n      data: entry,\n    });\n  }\n\n  return {\n    files,\n  };\n}\n\nfunction createDocMethods(\n  info: FileInfo,\n  load: () => CompiledMDXProperties | Promise<CompiledMDXProperties>,\n): DocMethods {\n  return {\n    info,\n    async getText(type) {\n      if (type === 'raw') {\n        const fs = await import('node:fs/promises');\n\n        return (await fs.readFile(info.fullPath)).toString();\n      }\n\n      const data = await load();\n      if (typeof data._markdown !== 'string')\n        throw new Error(\n          \"getText('processed') requires `includeProcessedMarkdown` to be enabled in your collection config.\",\n        );\n      return data._markdown;\n    },\n    async getMDAST() {\n      const data = await load();\n\n      if (!data._mdast)\n        throw new Error(\n          'getMDAST() requires `includeMDAST` to be enabled in your collection config.',\n        );\n      return JSON.parse(data._mdast);\n    },\n  };\n}\n"],"mappings":"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"}