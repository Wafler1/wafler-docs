{"version":3,"file":"browser.js","names":[],"sources":["../../src/runtime/browser.tsx"],"sourcesContent":["import { type ReactNode, type FC, use } from 'react';\nimport type { StandardSchemaV1 } from '@standard-schema/spec';\nimport type { DocCollection, DocsCollection } from '@/config/define';\nimport type { CompiledMDXProperties } from '@/loaders/mdx/build-mdx';\nimport type { InternalTypeConfig } from './types';\n\ntype CompiledMDXFile<\n  Name extends string,\n  Frontmatter,\n  TC extends InternalTypeConfig,\n> = CompiledMDXProperties<Frontmatter> & TC['DocData'][Name] & Record<string, unknown>;\n\nexport interface ClientLoaderOptions<Doc, Props> {\n  /**\n   * Loader ID (usually your collection name)\n   *\n   * The code splitting strategy of frameworks like Tanstack Start may duplicate `createClientLoader()` into different chunks.\n   *\n   * We use loader ID to share cache between multiple instances of client loader.\n   *\n   * @defaultValue ''\n   */\n  id?: string;\n\n  component: (loaded: Doc, props: Props) => ReactNode;\n}\n\nexport interface ClientLoader<Doc, Props> {\n  preload: (path: string) => Promise<Doc>;\n  /**\n   * Get a component that renders content with `use()`.\n   */\n  getComponent: (path: string) => FC<Props>;\n  /**\n   * Get react nodes that renders content, wraps `<Suspense>` by default.\n   */\n  useContent: undefined extends Props\n    ? (path: string, props?: Props) => ReactNode\n    : (path: string, props: Props) => ReactNode;\n}\n\nexport type BrowserCreate<Config, TC extends InternalTypeConfig> = ReturnType<\n  typeof browser<Config, TC>\n>;\n\nexport interface DocCollectionEntry<\n  Name extends string = string,\n  Frontmatter = unknown,\n  TC extends InternalTypeConfig = InternalTypeConfig,\n> {\n  raw: Record<string, () => Promise<CompiledMDXFile<Name, Frontmatter, TC>>>;\n\n  createClientLoader: <Props extends object | undefined = undefined>(\n    options: ClientLoaderOptions<CompiledMDXFile<Name, Frontmatter, TC>, Props>,\n  ) => ClientLoader<CompiledMDXFile<Name, Frontmatter, TC>, Props>;\n}\n\nexport function browser<Config, TC extends InternalTypeConfig>() {\n  return {\n    doc<Name extends keyof Config & string>(\n      _name: Name,\n      glob: Record<string, () => Promise<unknown>>,\n    ) {\n      const out: DocCollectionEntry = {\n        raw: glob as DocCollectionEntry['raw'],\n        createClientLoader({ id = _name as string, ...options }) {\n          return createClientLoader(this.raw, { id, ...options });\n        },\n      };\n\n      return out as Config[Name] extends DocCollection<infer Schema> | DocsCollection<infer Schema>\n        ? DocCollectionEntry<Name, StandardSchemaV1.InferOutput<Schema>, TC>\n        : never;\n    },\n  };\n}\n\nconst loaderStore = new Map<\n  string,\n  {\n    preloaded: Map<string, CompiledMDXProperties>;\n  }\n>();\n\nexport function createClientLoader<\n  Doc = CompiledMDXProperties,\n  Props extends object | undefined = undefined,\n>(\n  globEntries: Record<string, () => Promise<Doc>>,\n  options: ClientLoaderOptions<Doc, Props>,\n): ClientLoader<Doc, Props> {\n  const { id = '', component: useRenderer } = options;\n  const renderers: Record<string, FC<Props>> = {};\n  const loaders = new Map<string, () => Promise<Doc>>();\n  const store = loaderStore.get(id) ?? {\n    preloaded: new Map(),\n  };\n  loaderStore.set(id, store);\n\n  for (const k in globEntries) {\n    loaders.set(k.startsWith('./') ? k.slice(2) : k, globEntries[k]);\n  }\n\n  function getLoader(path: string) {\n    const loader = loaders.get(path);\n    if (!loader)\n      throw new Error(`[createClientLoader] ${path} does not exist in available entries`);\n    return loader;\n  }\n\n  function getRenderer(path: string): FC<Props> {\n    if (path in renderers) return renderers[path];\n\n    let promise: Promise<Doc> | undefined;\n    function Renderer(props: Props) {\n      let doc = store.preloaded.get(path);\n      doc ??= use((promise ??= getLoader(path)()));\n\n      return useRenderer(doc, props);\n    }\n\n    return (renderers[path] = Renderer);\n  }\n\n  return {\n    async preload(path) {\n      const loaded = await getLoader(path)();\n      store.preloaded.set(path, loaded);\n      return loaded;\n    },\n    getComponent(path) {\n      return getRenderer(path);\n    },\n    useContent(path: string, props: Props & object) {\n      const Comp = getRenderer(path);\n      return <Comp {...props} />;\n    },\n  } as ClientLoader<Doc, Props>;\n}\n"],"mappings":";;;;AAyDA,SAAgB,UAAiD;AAC/D,QAAO,EACL,IACE,OACA,MACA;AAQA,SAPgC;GAC9B,KAAK;GACL,mBAAmB,EAAE,KAAK,OAAiB,GAAG,WAAW;AACvD,WAAO,mBAAmB,KAAK,KAAK;KAAE;KAAI,GAAG;KAAS,CAAC;;GAE1D;IAMJ;;AAGH,MAAM,8BAAc,IAAI,KAKrB;AAEH,SAAgB,mBAId,aACA,SAC0B;CAC1B,MAAM,EAAE,KAAK,IAAI,WAAW,gBAAgB;CAC5C,MAAM,YAAuC,EAAE;CAC/C,MAAM,0BAAU,IAAI,KAAiC;CACrD,MAAM,QAAQ,YAAY,IAAI,GAAG,IAAI,EACnC,2BAAW,IAAI,KAAK,EACrB;AACD,aAAY,IAAI,IAAI,MAAM;AAE1B,MAAK,MAAM,KAAK,YACd,SAAQ,IAAI,EAAE,WAAW,KAAK,GAAG,EAAE,MAAM,EAAE,GAAG,GAAG,YAAY,GAAG;CAGlE,SAAS,UAAU,MAAc;EAC/B,MAAM,SAAS,QAAQ,IAAI,KAAK;AAChC,MAAI,CAAC,OACH,OAAM,IAAI,MAAM,wBAAwB,KAAK,sCAAsC;AACrF,SAAO;;CAGT,SAAS,YAAY,MAAyB;AAC5C,MAAI,QAAQ,UAAW,QAAO,UAAU;EAExC,IAAI;EACJ,SAAS,SAAS,OAAc;GAC9B,IAAI,MAAM,MAAM,UAAU,IAAI,KAAK;AACnC,WAAQ,IAAK,YAAY,UAAU,KAAK,EAAE,CAAE;AAE5C,UAAO,YAAY,KAAK,MAAM;;AAGhC,SAAQ,UAAU,QAAQ;;AAG5B,QAAO;EACL,MAAM,QAAQ,MAAM;GAClB,MAAM,SAAS,MAAM,UAAU,KAAK,EAAE;AACtC,SAAM,UAAU,IAAI,MAAM,OAAO;AACjC,UAAO;;EAET,aAAa,MAAM;AACjB,UAAO,YAAY,KAAK;;EAE1B,WAAW,MAAc,OAAuB;AAE9C,UAAO,oBADM,YAAY,KAAK,IACjB,GAAI,QAAS;;EAE7B"}