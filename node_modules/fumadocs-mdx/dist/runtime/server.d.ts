import { v as DocCollection, x as MetaCollection, y as DocsCollection } from "../core-CES68-08.js";
import "../config/index.js";
import { DocData, DocMethods, InternalTypeConfig, MetaMethods } from "./types.js";
import { StandardSchemaV1 } from "@standard-schema/spec";
import { MetaData, PageData, Source } from "fumadocs-core/source";

//#region src/runtime/server.d.ts
type MetaCollectionEntry<Data> = Data & MetaMethods;
type DocCollectionEntry<Name extends string = string, Frontmatter = unknown, TC extends InternalTypeConfig = InternalTypeConfig> = DocData & DocMethods & Frontmatter & TC['DocData'][Name];
type AsyncDocCollectionEntry<Name extends string = string, Frontmatter = unknown, TC extends InternalTypeConfig = InternalTypeConfig> = {
  load: () => Promise<DocData & TC['DocData'][Name]>;
} & DocMethods & Frontmatter;
interface DocsCollectionEntry<Name extends string = string, Frontmatter extends PageData = PageData, Meta extends MetaData = MetaData, TC extends InternalTypeConfig = InternalTypeConfig> {
  docs: DocCollectionEntry<Name, Frontmatter, TC>[];
  meta: MetaCollectionEntry<Meta>[];
  toFumadocsSource: () => Source<{
    pageData: DocCollectionEntry<Name, Frontmatter, TC>;
    metaData: MetaCollectionEntry<Meta>;
  }>;
}
interface AsyncDocsCollectionEntry<Name extends string = string, Frontmatter extends PageData = PageData, Meta extends MetaData = MetaData, TC extends InternalTypeConfig = InternalTypeConfig> {
  docs: AsyncDocCollectionEntry<Name, Frontmatter, TC>[];
  meta: MetaCollectionEntry<Meta>[];
  toFumadocsSource: () => Source<{
    pageData: AsyncDocCollectionEntry<Name, Frontmatter, TC>;
    metaData: MetaCollectionEntry<Meta>;
  }>;
}
type AwaitableGlobEntries<T> = Record<string, T | (() => Promise<T>)>;
type ServerCreate<Config, TC extends InternalTypeConfig = InternalTypeConfig> = ReturnType<typeof server<Config, TC>>;
interface ServerOptions {
  doc?: {
    passthroughs?: string[];
  };
}
declare function server<Config, TC extends InternalTypeConfig>(options?: ServerOptions): {
  doc<Name extends keyof Config & string>(_name: Name, base: string, glob: AwaitableGlobEntries<unknown>): Promise<Config[Name] extends DocCollection<infer Schema extends StandardSchemaV1<unknown, unknown>> | DocsCollection<infer Schema extends StandardSchemaV1<unknown, unknown>, StandardSchemaV1<unknown, unknown>> ? DocCollectionEntry<Name, StandardSchemaV1.InferOutput<Schema>, TC>[] : never>;
  docLazy<Name extends keyof Config & string>(_name: Name, base: string, head: AwaitableGlobEntries<unknown>, body: Record<string, () => Promise<unknown>>): Promise<Config[Name] extends DocCollection<infer Schema extends StandardSchemaV1<unknown, unknown>> | DocsCollection<infer Schema extends StandardSchemaV1<unknown, unknown>, StandardSchemaV1<unknown, unknown>> ? AsyncDocCollectionEntry<Name, StandardSchemaV1.InferOutput<Schema>, TC>[] : never>;
  meta<Name extends keyof Config & string>(_name: Name, base: string, glob: AwaitableGlobEntries<unknown>): Promise<Config[Name] extends MetaCollection<infer Schema extends StandardSchemaV1<unknown, unknown>> | DocsCollection<StandardSchemaV1<unknown, unknown>, infer Schema extends StandardSchemaV1<unknown, unknown>> ? MetaCollectionEntry<StandardSchemaV1.InferOutput<Schema>>[] : never>;
  docs<Name extends keyof Config & string>(name: Name, base: string, metaGlob: AwaitableGlobEntries<unknown>, docGlob: AwaitableGlobEntries<unknown>): Promise<Config[Name] extends DocsCollection<infer Page extends StandardSchemaV1<unknown, unknown>, infer Meta extends StandardSchemaV1<unknown, unknown>> ? StandardSchemaV1.InferOutput<Page> extends PageData ? StandardSchemaV1.InferOutput<Meta> extends MetaData ? DocsCollectionEntry<Name, StandardSchemaV1.InferOutput<Page>, StandardSchemaV1.InferOutput<Meta>, TC> : never : never : never>;
  docsLazy<Name extends keyof Config & string>(name: Name, base: string, metaGlob: AwaitableGlobEntries<unknown>, docHeadGlob: AwaitableGlobEntries<unknown>, docBodyGlob: Record<string, () => Promise<unknown>>): Promise<Config[Name] extends DocsCollection<infer Page extends StandardSchemaV1<unknown, unknown>, infer Meta extends StandardSchemaV1<unknown, unknown>> ? StandardSchemaV1.InferOutput<Page> extends PageData ? StandardSchemaV1.InferOutput<Meta> extends MetaData ? AsyncDocsCollectionEntry<Name, StandardSchemaV1.InferOutput<Page>, StandardSchemaV1.InferOutput<Meta>, TC> : never : never : never>;
};
declare function toFumadocsSource<Page extends DocMethods & PageData, Meta extends MetaMethods & MetaData>(pages: Page[], metas: Meta[]): Source<{
  pageData: Page;
  metaData: Meta;
}>;
//#endregion
export { AsyncDocCollectionEntry, AsyncDocsCollectionEntry, DocCollectionEntry, DocsCollectionEntry, MetaCollectionEntry, ServerCreate, ServerOptions, server, toFumadocsSource };
//# sourceMappingURL=server.d.ts.map