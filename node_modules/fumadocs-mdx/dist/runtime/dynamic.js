import { t as fumaMatter } from "../fuma-matter-DIHoctmS.js";
import "../preset-Y6J6llIV.js";
import { t as buildConfig } from "../build-ykm3F3Ef.js";
import { n as createCore } from "../core-B8ONGqXn.js";
import "../codegen-DzglA9tJ.js";
import "../remark-include-DmuKFQ_V.js";
import { t as buildMDX } from "../build-mdx-CKIy8c5h.js";
import { server } from "./server.js";
import fs from "node:fs/promises";
import { pathToFileURL } from "node:url";
import { executeMdx } from "@fumadocs/mdx-remote/client";

//#region src/runtime/dynamic.ts
async function dynamic(configExports, coreOptions, serverOptions) {
	const core = createCore(coreOptions);
	await core.init({ config: buildConfig(configExports) });
	const create = server(serverOptions);
	function getDocCollection(name) {
		const collection = core.getCollection(name);
		if (!collection) return;
		if (collection.type === "docs") return collection.docs;
		else if (collection.type === "doc") return collection;
	}
	function convertLazyEntries(collection, entries) {
		const head = {};
		const body = {};
		async function compile({ info, data }) {
			let content = (await fs.readFile(info.fullPath)).toString();
			content = fumaMatter(content).content;
			const compiled = await buildMDX(core, collection, {
				filePath: info.fullPath,
				source: content,
				frontmatter: data,
				isDevelopment: false,
				environment: "runtime"
			});
			return await executeMdx(String(compiled.value), { baseUrl: pathToFileURL(info.fullPath) });
		}
		for (const entry of entries) {
			head[entry.info.path] = () => entry.data;
			let cachedResult;
			body[entry.info.path] = () => cachedResult ??= compile(entry);
		}
		return {
			head,
			body
		};
	}
	return {
		async doc(name, base, entries) {
			const collection = getDocCollection(name);
			if (!collection) throw new Error(`the doc collection ${name} doesn't exist.`);
			const { head, body } = convertLazyEntries(collection, entries);
			return create.docLazy(name, base, head, body);
		},
		async docs(name, base, meta, entries) {
			const collection = getDocCollection(name);
			if (!collection) throw new Error(`the doc collection ${name} doesn't exist.`);
			const docs = convertLazyEntries(collection, entries);
			return create.docsLazy(name, base, meta, docs.head, docs.body);
		}
	};
}

//#endregion
export { dynamic };
//# sourceMappingURL=dynamic.js.map