{"version":3,"file":"load-from-file-XmVvZrXG.js","names":[],"sources":["../src/config/load-from-file.ts"],"sourcesContent":["import { pathToFileURL } from 'node:url';\nimport type { LoadedConfig } from '@/config/build';\nimport { buildConfig } from '@/config/build';\nimport type { Core } from '@/core';\n\nasync function compileConfig(core: Core) {\n  const { build } = await import('esbuild');\n  const { configPath, outDir } = core.getOptions();\n\n  const transformed = await build({\n    entryPoints: [{ in: configPath, out: 'source.config' }],\n    bundle: true,\n    outdir: outDir,\n    target: 'node20',\n    write: true,\n    platform: 'node',\n    format: 'esm',\n    packages: 'external',\n    outExtension: {\n      '.js': '.mjs',\n    },\n    allowOverwrite: true,\n  });\n\n  if (transformed.errors.length > 0) {\n    throw new Error('failed to compile configuration file');\n  }\n}\n\n/**\n * Load config\n *\n * @param build - By default, it assumes the config file has been compiled. Set this `true` to compile the config first.\n */\nexport async function loadConfig(core: Core, build = false): Promise<LoadedConfig> {\n  if (build) await compileConfig(core);\n\n  const url = pathToFileURL(core.getCompiledConfigPath());\n  // always return a new config\n  url.searchParams.set('hash', Date.now().toString());\n\n  const config = import(url.href).then((loaded) => buildConfig(loaded as Record<string, unknown>));\n\n  return await config;\n}\n"],"mappings":";;;;;;AAKA,eAAe,cAAc,MAAY;CACvC,MAAM,EAAE,UAAU,MAAM,OAAO;CAC/B,MAAM,EAAE,YAAY,WAAW,KAAK,YAAY;AAiBhD,MAfoB,MAAM,MAAM;EAC9B,aAAa,CAAC;GAAE,IAAI;GAAY,KAAK;GAAiB,CAAC;EACvD,QAAQ;EACR,QAAQ;EACR,QAAQ;EACR,OAAO;EACP,UAAU;EACV,QAAQ;EACR,UAAU;EACV,cAAc,EACZ,OAAO,QACR;EACD,gBAAgB;EACjB,CAAC,EAEc,OAAO,SAAS,EAC9B,OAAM,IAAI,MAAM,uCAAuC;;;;;;;AAS3D,eAAsB,WAAW,MAAY,QAAQ,OAA8B;AACjF,KAAI,MAAO,OAAM,cAAc,KAAK;CAEpC,MAAM,MAAM,cAAc,KAAK,uBAAuB,CAAC;AAEvD,KAAI,aAAa,IAAI,QAAQ,KAAK,KAAK,CAAC,UAAU,CAAC;AAInD,QAAO,MAFQ,OAAO,IAAI,MAAM,MAAM,WAAW,YAAY,OAAkC,CAAC"}