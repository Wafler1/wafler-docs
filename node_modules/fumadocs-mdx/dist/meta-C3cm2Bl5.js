import { n as metaLoaderGlob } from "./loaders-hcYVSfeh.js";
import { load } from "js-yaml";
import { z } from "zod";

//#region src/loaders/meta.ts
const querySchema = z.looseObject({
	collection: z.string().optional(),
	workspace: z.string().optional()
});
/**
* load meta files, fallback to bundler's built-in plugins when ?collection is unspecified.
*/
function createMetaLoader({ getCore }, resolve = {}) {
	const { json: resolveJson = "js" } = resolve;
	function parse(filePath, source) {
		try {
			if (filePath.endsWith(".json")) return JSON.parse(source);
			if (filePath.endsWith(".yaml")) return load(source);
		} catch (e) {
			throw new Error(`invalid data in ${filePath}`, { cause: e });
		}
		throw new Error("Unknown file type " + filePath);
	}
	function onMeta(source, { filePath, query }) {
		const parsed = querySchema.safeParse(query);
		if (!parsed.success || !parsed.data.collection) return null;
		const { collection: collectionName, workspace } = parsed.data;
		return async () => {
			let core = await getCore();
			if (workspace) core = core.getWorkspaces().get(workspace) ?? core;
			const collection = core.getCollection(collectionName);
			let metaCollection;
			switch (collection?.type) {
				case "meta":
					metaCollection = collection;
					break;
				case "docs":
					metaCollection = collection.meta;
					break;
			}
			const data = parse(filePath, source);
			if (!metaCollection) return data;
			return core.transformMeta({
				collection: metaCollection,
				filePath,
				source
			}, data);
		};
	}
	return {
		test: metaLoaderGlob,
		async load(input) {
			const result = onMeta(await input.getSource(), input);
			if (result === null) return null;
			const data = await result();
			if (input.filePath.endsWith(".json")) return {
				moduleType: resolveJson,
				code: resolveJson === "json" ? JSON.stringify(data) : `export default ${JSON.stringify(data)}`
			};
			else return {
				moduleType: "js",
				code: `export default ${JSON.stringify(data)}`
			};
		},
		bun: { load(source, input) {
			const result = onMeta(source, input);
			if (result === null) return {
				loader: "object",
				exports: parse(input.filePath, source)
			};
			return result().then((data) => ({
				loader: "object",
				exports: { default: data }
			}));
		} }
	};
}

//#endregion
export { createMetaLoader as t };
//# sourceMappingURL=meta-C3cm2Bl5.js.map