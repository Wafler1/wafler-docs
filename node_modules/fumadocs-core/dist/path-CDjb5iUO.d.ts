import { a as Separator, i as Root, n as Item, r as Node, t as Folder } from "./definitions-Cw2aM1Af.js";
import { I18nConfig } from "./i18n/index.js";
import { SlugFn } from "./source/plugins/slugs.js";
import { SerializedPageTree } from "./source/client/index.js";
import { ReactNode } from "react";

//#region src/source/source.d.ts
interface Source<Config extends SourceConfig = SourceConfig> {
  files: VirtualFile<Config>[];
}
interface SourceConfig {
  pageData: PageData;
  metaData: MetaData;
}
interface MetaData {
  icon?: string | undefined;
  title?: string | undefined;
  root?: boolean | undefined;
  pages?: string[] | undefined;
  defaultOpen?: boolean | undefined;
  collapsible?: boolean | undefined;
  description?: string | undefined;
}
interface PageData {
  icon?: string | undefined;
  title?: string;
  description?: string | undefined;
}
type VirtualFile<Config extends SourceConfig = SourceConfig> = VirtualPage<Config['pageData']> | VirtualMeta<Config['metaData']>;
interface BaseVirtualFile {
  /**
   * Virtualized path (relative to content directory)
   *
   * @example `docs/page.mdx`
   */
  path: string;
  /**
   * Absolute path of the file
   */
  absolutePath?: string;
}
interface VirtualPage<Data extends PageData> extends BaseVirtualFile {
  type: 'page';
  /**
   * Specified Slugs for page
   */
  slugs?: string[];
  data: Data;
}
interface VirtualMeta<Data extends MetaData> extends BaseVirtualFile {
  type: 'meta';
  data: Data;
}
type _ConfigUnion_<T extends Record<string, Source>> = { [K in keyof T]: T[K] extends Source<infer Config> ? {
  pageData: Config['pageData'] & {
    type: K;
  };
  metaData: Config['metaData'] & {
    type: K;
  };
} : never }[keyof T];
declare function multiple<T extends Record<string, Source>>(sources: T): Source<_ConfigUnion_<T>>;
declare function source<Page extends PageData, Meta extends MetaData>(config: {
  pages: VirtualPage<Page>[];
  metas: VirtualMeta<Meta>[];
}): Source<{
  pageData: Page;
  metaData: Meta;
}>;
interface _SourceUpdate_<Config extends SourceConfig> {
  files: <Page extends PageData, Meta extends MetaData>(fn: (files: VirtualFile<Config>[]) => (VirtualPage<Page> | VirtualMeta<Meta>)[]) => _SourceUpdate_<{
    pageData: Page;
    metaData: Meta;
  }>;
  page: <V extends PageData>(fn: (page: VirtualPage<Config['pageData']>) => VirtualPage<V>) => _SourceUpdate_<{
    pageData: V;
    metaData: Config['metaData'];
  }>;
  meta: <V extends MetaData>(fn: (meta: VirtualMeta<Config['metaData']>) => VirtualMeta<V>) => _SourceUpdate_<{
    pageData: Config['pageData'];
    metaData: V;
  }>;
  build: () => Source<Config>;
}
/**
 * update a source object in-place.
 */
declare function update<Config extends SourceConfig>(source: Source<Config>): _SourceUpdate_<Config>;
//#endregion
//#region src/source/storage/file-system.d.ts
/**
 * In memory file system.
 */
declare class FileSystem<File> {
  files: Map<string, File>;
  folders: Map<string, string[]>;
  constructor(inherit?: FileSystem<File>);
  read(path: string): File | undefined;
  /**
   * get the direct children of folder (in virtual file path)
   */
  readDir(path: string): string[] | undefined;
  write(path: string, file: File): void;
  /**
   * Delete files at specified path.
   *
   * @param path - the target path.
   * @param [recursive=false] - if set to `true`, it will also delete directories.
   */
  delete(path: string, recursive?: boolean): boolean;
  getFiles(): string[];
  makeDir(path: string): void;
}
//#endregion
//#region src/source/storage/content.d.ts
type ContentStorage<Config extends SourceConfig = SourceConfig> = FileSystem<ContentStorageFile<Config>>;
type ContentStorageFile<Config extends SourceConfig = SourceConfig> = ContentStorageMetaFile<Config> | ContentStoragePageFile<Config>;
interface ContentStorageMetaFile<Config extends SourceConfig = SourceConfig> {
  path: string;
  absolutePath?: string;
  format: 'meta';
  data: Config['metaData'];
}
interface ContentStoragePageFile<Config extends SourceConfig = SourceConfig> {
  path: string;
  absolutePath?: string;
  format: 'page';
  slugs: string[];
  data: Config['pageData'];
}
/**
 * convert input files into virtual file system.
 *
 * in the storage, locale codes are removed from file paths, hence the same file will have same file paths in every storage.
 */
declare function createContentStorageBuilder(loaderConfig: ResolvedLoaderConfig): {
  i18n(): Record<string, ContentStorage>;
  single(): ContentStorage;
};
//#endregion
//#region src/source/page-tree/builder.d.ts
interface PageTreeBuilderContext<Config extends SourceConfig = SourceConfig> {
  idPrefix: string;
  noRef: boolean;
  transformers: PageTreeTransformer<Config>[];
  builder: PageTreeBuilder;
  storage: ContentStorage<Config>;
  getUrl: ResolvedLoaderConfig['url'];
  storages?: Record<string, ContentStorage<Config>>;
  locale?: string;
  custom?: Record<string, unknown>;
}
interface PageTreeTransformer<Config extends SourceConfig = SourceConfig> {
  file?: (this: PageTreeBuilderContext<Config>, node: Item, filePath?: string) => Item;
  folder?: (this: PageTreeBuilderContext<Config>, node: Folder, folderPath: string, metaPath?: string) => Folder;
  separator?: (this: PageTreeBuilderContext<Config>, node: Separator) => Separator;
  root?: (this: PageTreeBuilderContext<Config>, node: Root) => Root;
}
interface PageTreeOptions<Config extends LoaderConfig = LoaderConfig> {
  /** generate URL from page */
  url: ResolvedLoaderConfig['url'];
  idPrefix?: string;
  /**
   * Remove references to the file path of original nodes (`$ref`)
   *
   * @defaultValue false
   */
  noRef?: boolean;
  /**
   * generate fallback page tree
   *
   * @defaultValue true
   */
  generateFallback?: boolean;
  /**
   * Additional page tree transformers to apply
   */
  transformers?: PageTreeTransformer<Config['source']>[];
  /** custom context */
  context?: Record<string, unknown>;
}
declare class PageTreeBuilder {
  private readonly flattenPathToFullPath;
  private readonly transformers;
  /** virtual file path -> output page tree node (if cached) */
  private readonly pathToNode;
  /** unfinished nodes */
  private readonly unfinished;
  private readonly ownerMap;
  private _nextId;
  /** passed as additional information to transformers */
  private readonly ctx;
  private readonly storage;
  constructor(input: ContentStorage | [locale: string, storages: Record<string, ContentStorage>], options: PageTreeOptions);
  resolveFlattenPath(name: string, format: string): string;
  /**
   * try to register as the owner of `node`.
   *
   * when a node is referenced by multiple folders, this determines which folder they should belong to.
   *
   * @returns whether the owner owns the node.
   */
  private own;
  private transferOwner;
  private generateId;
  buildPaths(paths: string[], filter?: (file: string) => boolean, reversed?: boolean): Node[];
  private resolveFolderItem;
  folder(folderPath: string): Folder | undefined;
  file(path: string): Item | undefined;
  root(id?: string, path?: string): Root;
}
//#endregion
//#region src/source/plugins/icon.d.ts
type IconResolver = (icon: string | undefined) => ReactNode;
//#endregion
//#region src/source/loader.d.ts
interface LoaderConfig {
  source: SourceConfig;
  i18n: I18nConfig | undefined;
}
interface LoaderOptions<C extends LoaderConfig = LoaderConfig> {
  baseUrl: string;
  i18n?: C['i18n'];
  url?: (slugs: string[], locale?: string) => string;
  /**
   * Additional options for page tree builder
   */
  pageTree?: Partial<PageTreeOptions<C>>;
  plugins?: LoaderPluginOption[] | ((context: {
    typedPlugin: (plugin: LoaderPlugin<C>) => LoaderPlugin;
  }) => LoaderPluginOption[]);
  icon?: IconResolver;
  slugs?: SlugFn<C>;
}
interface ResolvedLoaderConfig {
  source: Source;
  url: (slugs: string[], locale?: string) => string;
  plugins?: LoaderPlugin[];
  pageTree?: Partial<PageTreeOptions>;
  i18n?: I18nConfig | undefined;
}
interface SharedFileInfo {
  /**
   * Virtualized file path (relative to content directory)
   *
   * @example `docs/page.mdx`
   */
  path: string;
  /**
   * Absolute path of the file
   */
  absolutePath?: string;
}
interface Page<Data = PageData> extends SharedFileInfo {
  slugs: string[];
  url: string;
  data: Data;
  locale?: string | undefined;
}
interface Meta<Data = MetaData> extends SharedFileInfo {
  data: Data;
}
interface LoaderOutput<Config extends LoaderConfig> {
  pageTree: Config['i18n'] extends I18nConfig ? Record<string, Root> : Root;
  getPageTree: (locale?: string) => Root;
  /**
   * get referenced page from href, supported:
   *
   * - relative file paths, like `./my/page.mdx`.
   * - generated page pathname, like `/docs/my/page`.
   */
  getPageByHref: (href: string, options?: {
    language?: string;
    /**
     * resolve relative file paths in `href` from specified dirname, must be a virtual path.
     */
    dir?: string;
  }) => {
    page: Page<Config['source']['pageData']>;
    hash?: string;
  } | undefined;
  /**
   * resolve special hrefs in a page, including:
   *
   * - relative file paths, like `./my/page.mdx`.
   */
  resolveHref: (href: string, parent: Page<Config['source']['pageData']>) => string;
  /**
   * @internal
   */
  _i18n?: I18nConfig;
  /**
   * Get a list of pages from specified language
   *
   * @param language - If unspecified, list pages from all languages.
   */
  getPages: (language?: string) => Page<Config['source']['pageData']>[];
  /**
   * get each language and its pages, empty if i18n is not enabled.
   */
  getLanguages: () => {
    language: string;
    pages: Page<Config['source']['pageData']>[];
  }[];
  /**
   * Get page with slugs, the slugs can also be URI encoded.
   *
   * @param language - If unspecified, the default language will be used.
   */
  getPage: (slugs: string[] | undefined, language?: string) => Page<Config['source']['pageData']> | undefined;
  getNodePage: (node: Item, language?: string) => Page<Config['source']['pageData']> | undefined;
  getNodeMeta: (node: Folder, language?: string) => Meta<Config['source']['metaData']> | undefined;
  /**
   * generate static params for Next.js SSG
   *
   * @param slug - customise parameter name for slugs
   * @param lang - customise parameter name for lang
   */
  generateParams: <TSlug extends string = 'slug', TLang extends string = 'lang'>(slug?: TSlug, lang?: TLang) => (Record<TSlug, string[]> & Record<TLang, string>)[];
  /**
   * serialize page tree for non-RSC environments
   */
  serializePageTree: (tree: Root) => Promise<SerializedPageTree>;
}
declare function createGetUrl(baseUrl: string, i18n?: I18nConfig): ResolvedLoaderConfig['url'];
declare function loader<Config extends SourceConfig, I18n extends I18nConfig | undefined = undefined>(source: Source<Config>, options: LoaderOptions<{
  source: NoInfer<Config>;
  i18n: I18n;
}>): LoaderOutput<{
  source: Config;
  i18n: I18n;
}>;
declare function loader<Config extends SourceConfig, I18n extends I18nConfig | undefined = undefined>(options: LoaderOptions<{
  source: NoInfer<Config>;
  i18n: I18n;
}> & {
  source: Source<Config>;
}): LoaderOutput<{
  source: Config;
  i18n: I18n;
}>;
interface LoaderPlugin<Config extends LoaderConfig = LoaderConfig> {
  name?: string;
  /**
   * Change the order of plugin:
   * - `pre`: before normal plugins
   * - `post`: after normal plugins
   */
  enforce?: 'pre' | 'post';
  /**
   * receive & replace loader options
   */
  config?: (config: ResolvedLoaderConfig) => ResolvedLoaderConfig | void | undefined;
  /**
   * transform the storage after loading
   */
  transformStorage?: (context: {
    storage: ContentStorage<Config['source']>;
  }) => void;
  /**
   * transform the generated page tree
   */
  transformPageTree?: PageTreeTransformer<Config['source']>;
}
type LoaderPluginOption<Config extends LoaderConfig = LoaderConfig> = LoaderPlugin<Config> | LoaderPluginOption<Config>[] | undefined;
type InferPageType<Utils extends LoaderOutput<any>> = Utils extends LoaderOutput<infer Config> ? Page<Config['source']['pageData']> : never;
type InferMetaType<Utils extends LoaderOutput<any>> = Utils extends LoaderOutput<infer Config> ? Meta<Config['source']['metaData']> : never;
declare namespace path_d_exports {
  export { basename, dirname, extname, joinPath, slash, splitPath };
}
declare function basename(path: string, ext?: string): string;
declare function extname(path: string): string;
declare function dirname(path: string): string;
/**
 * Split path into segments, trailing/leading slashes are removed
 */
declare function splitPath(path: string): string[];
/**
 * Resolve paths, slashes within the path will be ignored
 * @param paths - Paths to join
 * @example
 * ```
 * ['a','b'] // 'a/b'
 * ['/a'] // 'a'
 * ['a', '/b'] // 'a/b'
 * ['a', '../b/c'] // 'b/c'
 * ```
 */
declare function joinPath(...paths: string[]): string;
declare function slash(path: string): string;
//#endregion
export { _SourceUpdate_ as A, FileSystem as C, SourceConfig as D, Source as E, source as M, update as N, VirtualFile as O, createContentStorageBuilder as S, PageData as T, PageTreeTransformer as _, LoaderOptions as a, ContentStorageMetaFile as b, LoaderPluginOption as c, ResolvedLoaderConfig as d, createGetUrl as f, PageTreeOptions as g, PageTreeBuilderContext as h, LoaderConfig as i, multiple as j, _ConfigUnion_ as k, Meta as l, PageTreeBuilder as m, InferMetaType as n, LoaderOutput as o, loader as p, InferPageType as r, LoaderPlugin as s, path_d_exports as t, Page as u, ContentStorage as v, MetaData as w, ContentStoragePageFile as x, ContentStorageFile as y };