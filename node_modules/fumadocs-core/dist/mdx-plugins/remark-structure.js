import { n as toMdxExport, t as flattenNode } from "../mdast-utils-gJMY143g.js";
import { remarkHeading } from "./remark-heading.js";
import { remark } from "remark";
import remarkGfm from "remark-gfm";
import { visit } from "unist-util-visit";
import { toMarkdown } from "mdast-util-to-markdown";

//#region src/mdx-plugins/remark-structure.ts
const remarkStructureDefaultOptions = {
	types: [
		"heading",
		"paragraph",
		"blockquote",
		"tableCell",
		"mdxJsxFlowElement"
	],
	exportAs: false
};
/**
* Extract content into structured data.
*
* By default, the output is stored into VFile (`vfile.data.structuredData`), you can specify `exportAs` to export it.
*/
function remarkStructure({ types = remarkStructureDefaultOptions.types, stringify, allowedMdxAttributes, exportAs = remarkStructureDefaultOptions.exportAs, ...stringifyOptions } = {}) {
	if (Array.isArray(allowedMdxAttributes)) {
		const arr = allowedMdxAttributes;
		allowedMdxAttributes = (_node, attribute) => attribute.type === "mdxJsxAttribute" && arr.includes(attribute.name);
	}
	if (Array.isArray(types)) {
		const arr = types;
		types = (node) => arr.includes(node.type);
	}
	stringify ??= defaultStringify({
		filterMdxAttributes: allowedMdxAttributes,
		...stringifyOptions
	});
	return (tree, file) => {
		const data = {
			contents: [],
			headings: []
		};
		let lastHeading;
		if (file.data.frontmatter) {
			const frontmatter = file.data.frontmatter;
			if (frontmatter._openapi?.structuredData) {
				data.headings.push(...frontmatter._openapi.structuredData.headings);
				data.contents.push(...frontmatter._openapi.structuredData.contents);
			}
		}
		visit(tree, (element) => {
			if (element.type === "root" || !types(element)) return;
			if (element.type === "heading") {
				element.data ||= {};
				element.data.hProperties ||= {};
				const id = element.data.hProperties.id;
				if (typeof id !== "string") {
					console.warn("[remark-structure] hProperties.id is missing in heading node, it is required to generate heading data. You can add remark-heading prior to remark-structure to generate heading IDs.");
					return "skip";
				}
				data.headings.push({
					id,
					content: flattenNode(element).trim()
				});
				lastHeading = id;
				return "skip";
			}
			const content = stringify.call(this, element).trim();
			if (content.length > 0) data.contents.push({
				heading: lastHeading,
				content
			});
			return "skip";
		});
		file.data.structuredData = data;
		if (exportAs) tree.children.unshift(toMdxExport(typeof exportAs === "string" ? exportAs : "structuredData", data));
	};
}
/**
* Extract data from markdown/mdx content
*/
function structure(content, remarkPlugins = [], options = {}) {
	return remark().use(remarkGfm).use(remarkPlugins).use(remarkHeading).use(remarkStructure, options).processSync(content).data.structuredData;
}
function defaultStringify(config = {}) {
	const { filterMdxAttributes = (node) => {
		switch (node.name) {
			case "TypeTable":
			case "Callout": return true;
			default: return false;
		}
	}, filterMdxElements = () => false } = config;
	function modHandler(handler) {
		return function(node, ...rest) {
			if (node.data?._string) return node.data._string.join("\n");
			switch (node.type) {
				case "mdxJsxFlowElement":
				case "mdxJsxTextElement": {
					const filteredAttributes = node.attributes.filter((attr) => filterMdxAttributes(node, attr));
					if (!filterMdxElements(node)) {
						let attrStr = "";
						for (const attr of filteredAttributes) {
							const str = typeof attr.value === "string" ? attr.value : attr.value?.value;
							if (!str) continue;
							attrStr += attr.type === "mdxJsxAttribute" ? `(${attr.name}=${str}) ` : `(${str}) `;
						}
						if (node.children.length === 0) return attrStr.trimEnd();
						return attrStr + rest[1].handle({
							type: "root",
							children: node.children
						}, ...rest);
					}
					const temp = node.attributes;
					node.attributes = filteredAttributes;
					const s = handler(node, ...rest);
					node.attributes = temp;
					return s;
				}
				default: return handler(node, ...rest);
			}
		};
	}
	const handlers = {
		...config.handlers,
		_custom(node, _, state, info) {
			const handlers = state.handlers;
			for (const k in handlers) handlers[k] = modHandler(handlers[k]);
			return state.handle(node.root, void 0, state, info);
		}
	};
	return function(root) {
		const defaultExtensions = this.data("toMarkdownExtensions") ?? [];
		return toMarkdown({
			type: "_custom",
			root
		}, {
			...this.data("settings"),
			...config,
			extensions: config.extensions ? [...defaultExtensions, ...config.extensions] : defaultExtensions,
			handlers
		});
	};
}

//#endregion
export { defaultStringify, remarkStructure, remarkStructureDefaultOptions, structure };